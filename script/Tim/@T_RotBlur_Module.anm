@回転ブラー
--track0:中心X,-5000,5000,0
--track1:中心Y,-5000,5000,0
--track2:ブラー量,0,1000,30
--track3:基準位置,-100,100,0
--dialog:サイズ保持/chk,local ck=1;角度解像度ダウン,local sdw=0;高精度表示/chk,local ap=1;高精度出力/chk,local sp=1;

	local userdata,w,h
	w,h=obj.getpixel()
	local r=math.sqrt(w*w+h*h)
	if ck==0 then
		local addX,addY=math.ceil((r-w)/2+1),math.ceil((r-h)/2+1)
		obj.effect("領域拡張","上",addY,"下",addY,"右",addX,"左",addX)
	end
	require("T_RotBlur_Module")
	userdata,w,h=obj.getpixeldata()
	obj.setanchor("track",0,"line");
	local dx = obj.track0
	local dy = obj.track1

	local BL=( not obj.getinfo("saving") and ap==1) or ( obj.getinfo("saving") and sp==1) 
	local TRB= BL and T_RotBlur_Module.RotBlur_S or T_RotBlur_Module.RotBlur_L
	TRB(userdata,w,h,obj.track2,dx,dy,obj.track3,sdw)
	obj.putpixeldata(userdata)

@放射ブラー
--track0:中心X,-5000,5000,0
--track1:中心Y,-5000,5000,0
--track2:ブラー量,0,1000,20
--track3:基準位置,-100,100,0
--dialog:サイズ保持/chk,local ck=1;表示限界倍率,local Sbai=3;

	obj.setanchor("track",0,"line")
	local dx=obj.track0
	local dy=obj.track1
	local Br=obj.track2
	local BasP=0.01*obj.track3
	Br=math.min(Br,200/(1+BasP)-0.1)
	local userdata,w,h
	local addX1,addX2,addY1,addY2=0,0,0,0
	if ck==0 then
		local w,h=obj.getpixel()
		local w2,h2=w/2,h/2
		Sbai=math.max(0,(Sbai-1)/2)
		local iw,ih=w*Sbai,h*Sbai
		local iBr1=1/(1-Br*(1+BasP)/200)
		local iBr2=1/(1+Br*(1-BasP)/200)
		addX1=(( w2>dx and iBr1 or iBr2 )-1)*(w2-dx) 
		addX2=((-w2<dx and iBr1 or iBr2 )-1)*(w2+dx) 
		addY1=(( h2>dy and iBr1 or iBr2 )-1)*(h2-dy) 
		addY2=((-h2<dy and iBr1 or iBr2 )-1)*(h2+dy) 
		addX1=(addX1>iw) and iw or addX1
		addX2=(addX2>iw) and iw or addX2
		addY1=(addY1>ih) and ih or addY1
		addY2=(addY2>ih) and ih or addY2
		addX1,addY1=math.ceil(math.max(addX1,1)),math.ceil(math.max(addY1,1))
		addX2,addY2=math.ceil(math.max(addX2,1)),math.ceil(math.max(addY2,1))
		obj.effect("領域拡張","上",addY2,"下",addY1,"右",addX1,"左",addX2)
	end
	require("T_RotBlur_Module")
	userdata,w,h=obj.getpixeldata()

	T_RotBlur_Module.RadBlur(userdata,w,h,Br,dx+(addX2-addX1)/2,dy+(addY2-addY1)/2,BasP)
	obj.putpixeldata(userdata)

@ハードブラー拡張
--track0:基準位置,-100,100,0
--track1:幅ﾗﾝﾀﾞﾑ%,0,100,50
--track2:丸み,-100,100,0
	RotBlur_BasP = obj.track0
	RotBlur_AmpR = obj.track1
	RotBlur_EG = obj.track2

@回転ハードブラー
--track0:中心X,-5000,5000,0
--track1:中心Y,-5000,5000,0
--track2:ブラー量,0,500,20
--track3:凹凸量,1,1000,40,1
--dialog:サイズ保持/chk,local ck=1;基準[-100〜100],BasP=0;幅ランダム%,AmpR=50;丸み[-100〜100],EG=0;簡易補正/chk,BM=0;└係数%,BMC=100;パターン,local rnds=1;

	local Br = obj.track2
	if Bx~=0 then
		local dx = obj.track0
		local dy = obj.track1
		local NN = obj.track3
		local BasP=RotBlur_BasP or (BasP or 0)
		local AmpR=RotBlur_AmpR or (AmpR or 100)
		local EG=RotBlur_EG or (EG or 0)
		BasP=0.01*math.max(-100,math.min(100,BasP))
		AmpR=1-0.01*math.max(0,math.min(100,AmpR))
		EG=0.01*math.max(-100,math.min(100,EG))
		local BM=BM or 0
		local BMC=BMC or 100
		rnds=math.abs(math.floor(rnds))
		obj.setanchor("track",0,"line");

		local userdata,w,h
		w,h=obj.getpixel()
		local r=math.sqrt(w*w+h*h)
		if ck==0 then
			local addX,addY=math.ceil((r-w)/2+1),math.ceil((r-h)/2+1)
			obj.effect("領域拡張","上",addY,"下",addY,"右",addX,"左",addX)
		end
		require("T_RotBlur_Module")
		userdata,w,h=obj.getpixeldata()
		if rnds==0 then
			rnds=math.floor(obj.time*obj.framerate)
		end
		if BM==1 then
			T_RotBlur_Module.RotBlur_L(userdata,w,h,Br*NN/r*BMC*0.015,dx,dy,0,1)
			obj.putpixeldata(userdata)
			userdata,w,h=obj.getpixeldata()
		end
		work = obj.getpixeldata("work")
		local LUD=T_RotBlur_Module.RotHardBlur(userdata,work,w,h,Br,r/2,dx,dy,NN,AmpR,EG,BasP,rnds)
		obj.putpixeldata(LUD)
		RotBlur_BasP = nil
		RotBlur_AmpR = nil
		RotBlur_EG = nil
	end

@放射ハードブラー
--track0:中心X,-5000,5000,0
--track1:中心Y,-5000,5000,0
--track2:ブラー量,0,200,20
--track3:凸数,3,500,20,1
--dialog:サイズ保持/chk,local ck=1;基準[-100〜100],local BasP=0;幅ランダム%,local AmpR=50;丸み[-100〜100],local EG=0;簡易補正/chk,local BM=0;└係数%,local BMC=100;パターン,local rnds=1;表示限界倍率,local Sbai=3;

	local Br = obj.track2*0.01
	if Bx~=0 then
		local dx = obj.track0
		local dy = obj.track1
		local NN = obj.track3
		BasP=RotBlur_BasP or (BasP or 0)
		AmpR=RotBlur_AmpR or (AmpR or 100)
		EG=RotBlur_EG or (EG or 0)
		BasP=0.01*math.max(-100,math.min(100,BasP))
		AmpR=1-0.01*math.max(0,math.min(100,AmpR))
		EG=0.01*math.max(-100,math.min(100,EG))
		rnds=math.abs(math.floor(rnds))
		obj.setanchor("track",0,"line");
		BMC=BMC or 100

		local userdata,w,h
		w,h=obj.getpixel()
		local r=math.sqrt(w*w+h*h)

		if ck==0 and Br>0 then
			Sbai=math.max(0,(Sbai-1)/2)
			local iw,ih=w*Sbai,h*Sbai
			local iBr=Br/2*(1+BasP)
			local addX,addY
			if iBr<1 then
				iBr=iBr/(1-iBr)
				addX,addY=(w/2+math.abs(dx))*iBr+1,(h/2+math.abs(dy))*iBr+1
				addX=(addX>iw) and iw or addX
				addY=(addY>ih) and ih or addY
			else
				addX,addY=iw,ih
			end
			addX,addY=math.ceil(addX),math.ceil(addY)
			obj.effect("領域拡張","上",addY,"下",addY,"右",addX,"左",addX)
		end
		require("T_RotBlur_Module")
		userdata,w,h=obj.getpixeldata()
		if rnds==0 then
			rnds=math.floor(obj.time*obj.framerate)
		end

		if BM==1 then
			T_RotBlur_Module.RadBlur(userdata,w,h,BMC*Br*NN/600,dx,dy,0)
			obj.putpixeldata(userdata)
			userdata,w,h=obj.getpixeldata()
		end
		work = obj.getpixeldata("work")
		local LUD=T_RotBlur_Module.RadHardBlur(userdata,work,w,h,Br,dx,dy,NN,AmpR,EG,BasP,rnds)
		obj.putpixeldata(LUD)
		RotBlur_BasP = nil
		RotBlur_AmpR = nil
		RotBlur_EG = nil
	end

@方向ハードブラー
--track0:ブラー量,0,2000,100
--track1:凹凸ｻｲｽﾞ,1,1000,30,1
--track2:角度,-3600,3600,0
--track3:丸み,-100,100,0
--dialog:サイズ保持/chk,local ck=1;基準[-100〜100],local BasP=0;幅ランダム%,local AmpR=50;簡易補正/chk,local BM=0;└係数%,local BMC=100;パターン,local rnds=1;表示限界倍率,local Sbai=3;

	local Bx=obj.track0
	if Bx~=0 then
		local dS=obj.track1
		local deg=obj.track2
		local EG=obj.track3*0.01;
		local rad=deg*math.pi/180
		BasP=RotBlur_BasP or (BasP or 0)
		AmpR=RotBlur_AmpR or (AmpR or 100)
		BasP=0.01*math.max(-100,math.min(100,BasP))
		AmpR=1-0.01*math.max(0,math.min(100,AmpR))
		BMC=BMC or 100
		rnds=math.abs(math.floor(rnds))
		if rnds==0 then
			rnds=math.floor(obj.time*obj.framerate)
		end
		local userdata,w,h
		w,h=obj.getpixel()
		if ck==0 then
			local cos,sin=math.cos(rad),math.sin(rad)
			Sbai=math.max(0,(Sbai-1)/2)
			local iw,ih=w*Sbai,h*Sbai
			local ds1= Bx*(1-BasP)/2
			local ds2=-Bx*(1+BasP)/2
			local addX1,addY1=ds1*cos,ds1*sin
			local addX2,addY2=ds2*cos,ds2*sin
			addX1,addX2=math.max(addX1,addX2),-math.min(addX1,addX2)
			addY1,addY2=math.max(addY1,addY2),-math.min(addY1,addY2)
			addX1=(addX1>iw) and iw or addX1
			addX2=(addX2>iw) and iw or addX2
			addY1=(addY1>ih) and ih or addY1
			addY2=(addY2>ih) and ih or addY2
			addX1,addY1=math.ceil(math.max(addX1,1)),math.ceil(math.max(addY1,1))
			addX2,addY2=math.ceil(math.max(addX2,1)),math.ceil(math.max(addY2,1))
			obj.effect("領域拡張","上",addY2,"下",addY1,"右",addX1,"左",addX2)
		end
		if BM==1 then
			obj.effect("方向ブラー","範囲",BMC*0.01*Bx/dS/2,"角度",90+deg,"サイズ固定",1)
		end
		require("T_RotBlur_Module")
		userdata,w,h=obj.getpixeldata()
		work = obj.getpixeldata("work")
		local LUD=T_RotBlur_Module.DirHardBlur(userdata,work,w,h,Bx,dS,rad,AmpR,EG,BasP,rnds)
		obj.putpixeldata(LUD)
		RotBlur_BasP = nil
		RotBlur_AmpR = nil
		RotBlur_EG = nil
	end

@渦
--track0:中心X,-5000,5000,0
--track1:中心Y,-5000,5000,0
--track2:渦量,-3000,3600,100
--track3:変化,0,1,0,1
--dialog:サイズ保持/chk,local ck=1;

	obj.setanchor("track",0,"line");
	local dx = obj.track0
	local dy = obj.track1
	local sw = obj.track2
	local ch = obj.track3
	local userdata,w,h
	w,h=obj.getpixel()
	local r=math.sqrt(w*w+h*h)
	if ck==0 then
		local addX,addY=math.ceil((r-w)/2+1),math.ceil((r-h)/2+1)
		obj.effect("領域拡張","上",addY,"下",addY,"右",addX,"左",addX)
	end
	require("T_RotBlur_Module")
	userdata,w,h=obj.getpixeldata()
	local work=obj.getpixeldata("work")
	local LUD=T_RotBlur_Module.Whirlpool(userdata,work,w,h,sw,r/2,dx,dy,ch)
	obj.putpixeldata(LUD)
