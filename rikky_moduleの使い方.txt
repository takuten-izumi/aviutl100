################前書き######################################

	このdllが対応しているAviutl本体のバージョンは
	0.99i6(バージョン表記までなら0.96g)から1.10までです
	拡張編集exedit.aufのバージョンは
	0.89jから0.92までです
	ただしAviUtl本体と拡張編集との対応の兼ね合いで拡張編集は0.89l以降が推奨環境です
	ちなみに0.89lとは2011年に発表されたバージョンなので、もう誰も使っていないと思われます
	このdllのバージョンは1.4bです
	またdllを使うにはrikky_memory.aufが必要になります。
	aviut.exeと同じ場所に置いてください。
	このプラグインは拙作の他のプラグインとも連携しているので必要になる場合があります

&&&&&&&&&&&&&&&&免責&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

	このDLLやAUFの機能を用いて起きたいかなる問題や損害に作者やスクリプトを作った制作者は一切の責任を負いません
	自己の責任の上で使用して下さい

****************使い方**************************************

	このdllはscriptフォルダかexedit.aufがあるフォルダに置いてください
	全員がこのように置いてくれたならば、以下のようなことをする必要もなります
	dllを使う方法として一般的にはrequire関数を用いて
	require("rikky_module")とします
	しかしこれはrikky_module.dllがないとエラーになりスクリプト全体が動かなくなります
	作ったスクリプトにおいてこのdllの関数が必要なものならばrequireを用いても問題ないですが
	あると便利ですよ程度に用いるの場合は
	local f=package.loadlib(path.."rikky_module.dll","luaopen_rikky_module")
	という一文を追加します
	このpathはobj.getinfo("script_path")で得られる、そのスクリプトファイルがある階層の絶対パスです
	このfがnilならばrikky_module.dllがないことになるのでその処理をしなければいいだけになります
	例としては
	local path = obj.getinfo("script_path")
	local f = package.loadlib(path .. "rikky_module.dll", "luaopen_rikky_module")
	if f then
	  f().file(1)
	end
	のようになります
	f().がrikky_module.と同じ役割を担うのであとは具体的に使いたい関数を.(ピリオド)のあとにつけるだけです
	もしくはcpathを用いて
	if rikky_module == nil then
	  local CPATH = {}
	  local cpath = package.cpath .. ";"
	  local n
	  while(1)do
	    n = cpath:find(";")
	    if n then
	      CPATH[#CPATH + 1] = cpath:sub(1, n - 1)
	      cpath = cpath:sub(n + 1, #cpath)
	    else
	      break
	    end
	  end
	  if not CPATH[2]:find("script\\?.dll") then
	    CPATH[3] = CPATH[2]:sub(1, CPATH[2]:find("\\script\\")) .. "script\\?.dll"
	    package.cpath = package.cpath .. ";" .. CPATH[3]
	  end
	  for i = 1, #CPATH do
	    local f = io.open(CPATH[i]:gsub("?", "rikky_module"), "rb")
	    if f then
	      require("rikky_module")
	      f:close()
	      break
	    end
          end
	end
	のようにすれば、アニメーション効果ファイルと同じ階層にrikky_module.dllがある必要はなく、単にscriptフォルダやpluginsフォルダあればいいことになります
	他にもpcall(require, "rikky_module")を実行してfalseが返ってくると、呼び出し失敗ということになります

@@@@@@@@@@@@@@@@@関数の説明@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	※全体の共通の了解として、○○関数といわれたら、rikky_module.○○()のように使うことを意味します
	※引数は数値はnumber、文字列はstring、テーブルはtable、ブ―リアンはboolean、ユーザーデータはuserdataと表記します
	※引数が省略可能の場合は[]でくくって説明しています、例としてa(number [, number])となっていたらa関数の第2引数は省略可能で入力するのは数値になります

getinfo関数
	この関数はaviutlやexeditやオブジェクトの情報を取得できます
	getinfo(string [, number])のように使います
	stringは取得したいものを指定してください
	戻り値は指定したものによって、数、種類が変わってきます
	stringの種類

	"version" : 各種バージョンを取得できます
		string = rikky_module.getinfo("version" [, number])
		numberの種類
		指定なし : aviutl.exe本体のバージョンの文字列を返します、最新は1.10
		1        : 拡張編集exedit.aufのバージョンの文字列を返します、最新は0.92
		2        : rikky_module.dllのバージョンの文字列を返します、最新は1.4b
		3        : rikky_memory.aufのバージョンの文字列を返します、最新は0.6b
		4        : aviutl.exeのバージョンの通し番号の数値を返します、最新は53
		5        : 拡張編集exedit.aufのバージョンの通し番号の数値を返します、最新は53

	"frame" : プロジェクト全体に対する現在のフレーム数とプロジェクト全体のフレーム数を取得できます
		number, number = rikky_module.getinfo("frame")
		現在のフレーム数と全体のフレーム数の2つの数値を返します

	"aup" : 現在AviUtlが保持しているプロジェクトファイルのaupまでのパス(プロジェクト名)を取得できます
		string = rikky_module.getinfo("aup" [, number])
		numberの種類
		指定なし : フルパスの文字列を返します
		1        : ファイル名だけの文字列を返します
		
	"output" : 現在AviUtlが保持している書き出しするファイル名のパス(ファイル名)を取得できます
		string = rikky_module.getinfo("output" [, number])
		numberの種類
		指定なし : フルパスの文字列を返します
		1        : ファイル名だけの文字列を返します

	"state" : AviUtlが編集中か書き出し中か再生中かの状態を取得できます
		string = rikky_module.getinfo("state")
		編集中は"editing"、書き出し中は"saving"、再生中は"playing"のいずれかの文字列を返します

	"path" : aviutl.exeやexedit.aufのあるバス(場所のフォルダ)を取得できます
		string = rikky_module.getinfo("path" [, number])
		numberの種類
		指定なし : aviutl.exeがあるフォルダの文字列を返します、文字列の最後は\\
		1        : 拡張編集exedit.aufがあるフォルダの文字列を返します、文字列の最後は\\
		2        : デスクトップの文字列を返します、文字列の最後は\\

	"focus" : オブジェクトが選択中かどうかを取得できます
		boolean = rikky_module.getinfo("focus")
		numberの指定はなく、編集ウインドウが出ている場合はtrue、出ていない場合はfalseのブ―リアンを返します

	"blend" : オブジェクトの合成モードを取得できます
		number or string = rikky_module.getinfo("blend" [, number])
		numberの種類
		指定なし : obj.setoption("blend")で設定した合成モードの数値を返します
		1        : 編集ウインドウのオブジェクト自体の合成モードの数値を返します
		2        : obj.setoption("blend")で設定した合成モードの数値か文字列を返します
		戻り値の数値の種類は
		通常は0、加算は1、減算2
		乗算3、スクリーン4、オーバーレイ5
		比較(明)6、比較(暗)7、輝度8
		色差9、陰影10、明暗11、差分12
		また"alpha_add"は20、"alpha_max"は21、"alpha_sub"は22、"alpha_add2"は25
		optionが2ならばそのまま"alpha_add"や"alpha_sub"が返ってきます

	"group" : グループ制御の情報を取得できます
		table, boolean = rikky_module.getinfo("group")
		グループ制御の情報が入ったテーブルとグループ制御下にあるかのブーリアンの2つが返ってきます。
		グループ制御の情報が入ったテーブルのキーは以下のものです
		キーの種類
		zoom : 呼び出したオブジェクトに影響するグループ制御の拡大率の数値
		x    : 呼び出したオブジェクトに影響するグループ制御のX座標の数値
		y    : 呼び出したオブジェクトに影響するグループ制御のY座標の数値
		z    : 呼び出したオブジェクトに影響するグループ制御のZ座標の数値
		Xx   : 呼び出したオブジェクトに影響するグループ制御のX軸のベクトルXのx成分の数値
		Xy   : 呼び出したオブジェクトに影響するグループ制御のX軸のベクトルXのy成分の数値
		Xz   : 呼び出したオブジェクトに影響するグループ制御のX軸のベクトルXのz成分の数値
		Yx   : 呼び出したオブジェクトに影響するグループ制御のY軸のベクトルYのx成分の数値
		Yy   : 呼び出したオブジェクトに影響するグループ制御のY軸のベクトルYのy成分の数値
		Yz   : 呼び出したオブジェクトに影響するグループ制御のY軸のベクトルYのz成分の数値
		Zx   : 呼び出したオブジェクトに影響するグループ制御のZ軸のベクトルZのx成分の数値
		Zy   : 呼び出したオブジェクトに影響するグループ制御のZ軸のベクトルZのy成分の数値
		Zz   : 呼び出したオブジェクトに影響するグループ制御のZ軸のベクトルZのz成分の数値
		グループ制御下に入っている場合はtrue、入っていなければfalseになります
		ただし、描画先が仮想バッファになっている場合は常にfalseになります
		例として描画したい位置がX、Y、Zだった場合は
		x = (group.Xx * X + group.Yx * Y + group.Zx * Z) * group.zoom + group.x
		y = (group.Xy * X + group.Yy * Y + group.Zy * Z) * group.zoom + group.y
		z = (group.Xz * X + group.Yz * Y + group.Zz * Z) * group.zoom + group.z
		グループ制御の影響を受けたx、y、zを出すことができます

	"root" : 現在のシーンやルートを取得できます
		number = rikky_module.getinfo("root")
		ルートやシーンの数値を返します
		ルートは0です

	"text" : テキストオブジェクトに関する情報を取得できます
		string = rikky_module.getinfo("text" [, number])
		numberの種類
		指定なし : 直前のテキストオブジェクトやobj.load("text")で呼び出した文字列を返します
		1 〜 100 : 同じフレームの指定したレイヤにあるテキストオブジェクトの文字列を返します

	"buffer" : 現在の描画先を取得できます
		string = rikky_module.getinfo("buffer")
		描画先が仮想バッファかならば"tmp"、フレームバッファならば"frm"の文字列を返します

	"dialog" : パラメーター設定ウインドウの有無を取得できます
		boolean = rikky_module.getinfo("dialog")
		ウインドウが表示されているときはtrue、されていないときはfalseのブ―リアンを返します

	"object" : 呼び出されたオブジェクトの種類を取得できます
		string, table = rikky_module.getinfo("object")
		オブジェクトの名称の文字列とそのオブジェクトの色情報などが入ったテーブルの2つを返します
		オブジェクトの名称は以下のとおりです
		"動画ファイル"、"画像ファイル"、"テキスト"
		"図形"、"フレームバッファ"、"音声波形"
		"シーン"、"直前オブジェクト"、"フィルタオブジェクト"
		"カスタムオブジェクト"、"グループ制御"
		ただし、その他不明や未対応のオブジェクトならば、"不明"の文字列を返します
		情報のテーブルはオブジェクトに種類によってキーが変わります
		"動画ファイル"
			キーの種類
			file         : 参照している動画のパスの文字列
			loop         : ループ再生が有効なら1、無効なら0の数値
			alphachannel : アルファチャンネルが有効なら1、無効なら0の数値
		"画像ファイル" 
			キーの種類
			file : 参照している動画のパスの文字列
		"テキスト"
			color      : テキストの色の数値、0xRRGGBBの形式
			color2     :テキストの縁取りまたは影の色の数値、0xRRGGBBの形式 
			type       : 文字装飾(0が装飾なし、1が影、2が薄い影、3が縁取り、4が薄い縁取り)の数値
			autoadjust : 長さを自動調節が有効なら1、無効なら0の数値
			soft       : 滑らかにするかが有効なら1、無効なら0の数値
			monospace  : 等間隔モードが有効なら1、無効なら0の数値
			align      : 文字寄せ(0が横書左上、1が横書中上、2が横書右上、3が横書左中、4が横書中中、5が横書右中、6が横書左下、7が横書中下、8が横書右下、9が縦書右上、10が縦書右中、11が縦書右下、12が縦書中上、13が縦書中中、14が縦書中下、15が縦書左上、16が縦書左中、17が縦書左下)の数値
			spacing_x  : 字間(-100から100まで)の数値
			spacing_y  : 行間(-100から100まで)の数値
			presision  : 高精度が有効なら1、無効なら0の数値
			font       : フォントの文字列
			individual : 文字毎に個別オブジェクトが有効なら1、無効なら0の数値
			display    : 移動座標上に表示するが有効なら1、無効なら0の数値
			autoscroll : 自動スクロールが有効なら1、無効なら0の数値
			bold       : 太字が有効なら1、無効なら0の数値
			italic     : 斜字有効なら1、無効なら0の数値
		"図形"
			color  : 図形の色の数値、0xRRGGBBの形式
			figure : 背景や円といった形の文字列、ファイルを参照している場合はそのファイルのフルパス
		"フレームバッファ"
			bufferclear : フレームバッファをクリアするが有効なら1、無効なら0の数値
		"音声波形"
			color        : 波形の色の数値、0xRRGGBBの形式
			projectsound : 偏執全体の音声を基にするが有効なら1、無効なら0の数値
			file         : 参照ファイルのフルパスの文字列
			type         : 波形の形(0がType1、1がType2、2がType3、3がType4、4がType5)の数値
			mode         : 波形タイプの数値
			res_w        : 横解像度の数値
			res_h        : 縦解像度の数値
			pad_w        : 横スペース(%)の数値
			pad_h        : 縦スペース(%)の数値
			mirror       : ミラーの数値
		"シーン"
			loop         : ループ再生が有効なら1、無効なら0の数値
			scnenenumber : 呼び出しているシーン番号の数値
		"カメラ制御"
			zbuffer : Zバッファ/シャドウマップを有効にするが有効なら1、無効なら0の数値
		それ以外は空のテーブルです

	"start_end" : オブジェクトの始まりと終わりのフレーム数を取得できます
		number, number = rikky_module.getinfo("start_end")
		呼び出したオブジェクトの始まりと終わりの全体のフレーム数2つの数値を返します

	"filter" : オブジェクトにつけているフィルタ効果を取得できます
		table, number, number = rikky_module.getinfo("filter" [, option])
		フィルタ効果やアニメーション効果の名前の文字列が入ったテーブルと、現在の位置の数値と、ついているフィルタの総数の数値の3つを返します
		numberの種類
		指定なし : 各フィルタ効果が無効有効にかかわらずすべてをtableに収めます
		1        : 無効のフィルタ効果を外すようにします

	"shadow" : カメラ制御オプションのシャドー対象の有無を取得できます
		number = rikky_module.getinfo("shadow")
		シャドー対象が有効ならば1、無効ならば0の数値を返します、1がシャドー対象有効
		フィルタのカメラ制御オプション以外にもobj.setoption("shadow")で設定した場合の数値も取得できます

	"antialias" : アンチエイリアスの有無を取得できます
		number = rikky_module.getinfo("antialias")
		アンチエイリアスが有効ならば1、無効ならば0の数値を返します

	"culling" : 裏面を非表示するかの有無を取得できます
		number = rikky_module.getinfo("culling")
		裏面を描画する場合は0、非描画の場合は1の数値を返します
		ただし、オブジェクト側の裏面非表示にチェックを入れている場合は、obj.setoption("culling")で設定していても1を返します

	"billboard" : カメラ制御オプションのカメラの方向を向くの有無を取得できます
		number = rikky_module.getinfo("billboard")
		オブジェクトが向く方向(0がカメラの方向を見るのオプションはなし、1のときは横方向だけ見るを有効、2のときは横と縦の方向だけを見るを有効、3は横と縦の方向と回転を有効)の数値を返します
		フィルタのカメラ制御オプション以外にもobj.setoption("billboard")で設定した場合の数値も取得できます

	"force" : 合成モードの強制の有無を取得できます
		number = rikky_module.getinfo("force")
		強制が有効の場合1、無効の場合0の数値を返します

	"input" : 現在AviUtlが読み込むことができる拡張子を取得できます
		table, number = rikky_module.getinfo("input")
		ピリオドを含めた拡張子が収められたテーブルとその要素数の数値を返します

	"hwnd" : AviUtlの各ウィンドウのハンドルを返します
		number or table, string or table [, number] = rikky_module.getinfo("hwnd" [,option])
		オプションの数値なし、または指定以外の場合はメインウィンドウのハンドルの数値とウインドウの名前の文字列が返ります
		オプションの数値が1の場合は、オブジェクトの操作ウィンドウのハンドルと名前が返ります(ディスプレイ上になくとも、ハンドルは存在しています)
		オプションの数値が2の場合は、再生ウィンドウのハンドルと名前が返ります(ディスプレイ上になくとも、ハンドルは存在しています)
		オプションの数値が3の場合は、現在表示されているウィンドウのハンドルと名前が入ったテーブル2つと、テーブルの要素数が返ります
		オプションの数値が4の場合は、すべてのウィンドウのハンドルと名前が入ったテーブル2つと、テーブルの要素数が返ります

	"count" : AviUtlの処理実行の総数を返します
		number = rikky_module.getinfo("count")
		新しいプロジェクトを開始すると0からになります

	"cache" : obj.copybufferのcacheに保存されている名称を返します
		table, number = rikky_module.getinfo("cache")
		tableにはstringが収められていて、stringはキャッシュ名cache:○○の○○部分です
		numberはテーブルの要素の数です

	"groups" : グループ化したオブジェクトの順番と総数を返します
		number, number, number = rikky_module.getinfo("groups")
		第1戻り値はグループ化した同じグループ内での順番で、obj.indexのようなものです
		第2戻り値はグループ化した同じグループ内の総数で、obj.numのようなものです
		第3戻り値はグループ化のidのようなもので、0以上の数です
		グループ化していないとidは0です

	"font" : obj.setfontで設定されている設定を返します
		table = rikky_module.getinfo("font")
		tableには複数のキーが設定されています
		"name"   : フォントの名前で、縦書の場合は先頭に半角の@がつきます
		"size"   : フォントのサイズです
		"bold"   : 太字になっているかで、なっているときはtrue、違う場合はfalseのboolean型です
		"italic" : 斜字になっているかで、なっているときはtrue、違う場合はfalseのboolean型です
		"color"  : フォントの色です
		"color2" : フォントの装飾に使われる色です
		"type"   : フォントの装飾のタイプで、0だとなし、1だと影、2だと薄影、3だと縁取り、4だと細縁取りです
		color、color2、typeはスクリプトごとに初期状態(0xffffff、0x0、0)に戻るので、テキストオブジェクトの色を取得したい場合はgetinfo("object")を使用してください

	"draw_state" : 描画済みかを取得できます
		boolean = rikky_module.getinfo("draw_state")
		描画済みの場合はtrue、未描画の場合はfalseです

file関数
fold関数
font関数
	設定ダイアログ内で、ファイル選択やフォルダー選択を行う別ウインドウを表示させることができます
	アニメーション効果で使ってください
	rikky_module.file(number [, number, number, ...])
	rikky_module.fold(number [, number, number, ...])
	rikky_module.font(number [, number, number, ...])
	ファイル選択を行う場合はfile関数、フォルダー選択を行う場合はfold関数、フォント選択を行う場合はfont関数を使います
	数値は選択した結果を収める項目欄の番号で1から16のいずれかです
	1つの関数で複数の項目を設定できます
	file関数はスクリプトの--dialogで項目名の先頭に*(アスタリスク)をつけると、ファイル名だけになります
	例
	--dialog:ファイル,file="";
	rikky_module.file(1)

	スクリプトファイル内でこのように記述するとパラメータ設定ダイアログを出したときに
	「ファイル」の部分がボタンに変化します
	文字を扱うので、変数のところは=""のような形にしてください

list関数
	設定ダイアログ内で、選択させるリストの別ウインドウを表示させることができます
	アニメーション効果で使ってください
	rikky_module.list(number , table [, number, table, ...])
	数値は結果を収める項目欄の番号で1から16のいずれかです
	テーブルは表示したいリストを指定します、{"東", "西", "南", "北"}とすれば、ユーザーにこのいずれかを選択してもらえます
	数値とテーブルはワンセットです
	通常は収めた通りの文字列を項目欄に収めますが、項目名の先頭に*(アスタリスク)をつけると、リストの項目番号の数値の文字列を収めるようになります
	例
	--dialog:リスト:list="";
	rikky_module.list(1, {"東", "西", "南", "北"})

	スクリプトファイル内でこのように記述するとパラメータ設定ダイアログを出したときに
	「リスト」の部分がボタンに変化します
	文字を扱うので、変数のところは=""のような形にしてください	
	
png関数
jpg関数
bmp関数
	オブジェクトをpngやjpgやbmpファイルとして出力することができます
	引数にファイル名の文字列を渡すと、aviutl.exeがある階層にそのファイルができます
	ファイル名だけでなく、フルパスを渡すとその場所にファイルができます
	rikky_module.png(string)
	rikky_module.bmp(string)
	rikky_module.jpg(string [, number])
	ただし、jpg関数は数値を指定することで、出来上がる画像の質を変更することができます

dir関数
	指定した場所のにあるファイル名を一挙に取得できます
	table = rikky_module.dir(string, string)
	第1引数にファイルを取得するフォルダのフルパスを指定します
	第2引数以降は取得したい目的の拡張子を指定します
	ただし、第2引数に""空文字を入れるとフォルダ、"*all"にするとフォルダ内のすべてのファイルパスを取得するようになります
	戻り値は指定したファイルやフォルダのフルパスが入ったテーブルです

key関数
	キーボートやマウスクリックの挙動を取得できます
	table [, table] = rikky_module.key(string or number [, string or number, ...])
	引数に状態を取得したいキーに対応した文字列か数値を指定していきます
	引数の順番で戻り値のテーブルに各キーの状態がbooleanで収められています
	押されているときはtrue、押されていないときはfalseになります
	引数の文字列として使えるのは以下のものです
	キーボードと数字の対応は
	ローマ字26文字(大文字小文字どちらも可)
	"0"〜"9"の数字(テンキーではない)
	"ENTER"または"RETURN"
	"CTRL"
	"SHIFT"
	"ALT"
	"F1"〜"F24"(ファンクションキー)
	"←"、"↑"、"→"、"↓"
	"LB"(マウスの左クリック)、"RB"(マウスの右クリック)
	"JOYPAD"
	引数に"JOYPAD"の文字列を指定すると、2つ目の戻り値が返えるようになります
	1つ目のテーブルのJOYPADの対応する位置はJOYPADが有効ならばtrue、無効ならばfalseが入ります
	キーの種類
	left     : コントローラーの左側の状態を表すブーリアン
	right    : コントローラーの右側の状態を表すブーリアン
	up       : コントローラーの上側の状態を表すブーリアン
	down     : コントローラーの下側の状態を表すブーリアン
	button1  : コントローラーの1番に設定されてるボタンの状態を表すブーリアン
	button2  : コントローラーの2番に設定されてるボタンの状態を表すブーリアン
	button3  : コントローラーの3番に設定されてるボタンの状態を表すブーリアン
	button4  : コントローラーの4番に設定されてるボタンの状態を表すブーリアン
	button5  : コントローラーの5番に設定されてるボタンの状態を表すブーリアン
	button6  : コントローラーの6番に設定されてるボタンの状態を表すブーリアン
	button7  : コントローラーの7番に設定されてるボタンの状態を表すブーリアン
	button8  : コントローラーの8番に設定されてるボタンの状態を表すブーリアン
	button9  : コントローラーの9番に設定されてるボタンの状態を表すブーリアン
	button10 : コントローラーの10番に設定されてるボタンの状態を表すブーリアン
	button11 : コントローラーの11番に設定されてるボタンの状態を表すブーリアン
	button12 : コントローラーの12番に設定されてるボタンの状態を表すブーリアン
	button13 : コントローラーの13番に設定されてるボタンの状態を表すブーリアン
	button14 : コントローラーの14番に設定されてるボタンの状態を表すブーリアン
	button15 : コントローラーの15番に設定されてるボタンの状態を表すブーリアン
	button16 : コントローラーの16番に設定されてるボタンの状態を表すブーリアン
	button17 : コントローラーの17番に設定されてるボタンの状態を表すブーリアン
	button18 : コントローラーの18番に設定されてるボタンの状態を表すブーリアン
	button19 : コントローラーの19番に設定されてるボタンの状態を表すブーリアン
	button20 : コントローラーの20番に設定されてるボタンの状態を表すブーリアン
	button21 : コントローラーの21番に設定されてるボタンの状態を表すブーリアン
	button22 : コントローラーの22番に設定されてるボタンの状態を表すブーリアン
	button23 : コントローラーの23番に設定されてるボタンの状態を表すブーリアン
	button24 : コントローラーの24番に設定されてるボタンの状態を表すブーリアン
	引数の最後に"PASSED"を指定すると、リアルタイムでの反応ではなくなります
	http://e-words.jp/p/r-ascii.html
	http://wisdom.sakura.ne.jp/system/winapi/win32/win32.html
	あたりを見てください

find関数
	string.findと使い方は同じで、文字列の中に特定の文字列が入っているか調べることができます
	number or nil = rikky_module.find(string, string)
	1番目の引数の文字列の中に2番目の引数の文字列があれば、その位置の数値を返します
	なければnilを返します
	この数値は、全角だと2つ進みます

type関数
	type関数と同じで、引数のデータ型を取得できます
	string [string, ...] = rikky_module.type(number or string or table or boolean or function or userdata or nil [, number or string or table or boolean or function or userdata or nil, ...])
	渡した引数のデータ型の文字列を返します
	引数の数だけ戻り値があります
	
desk関数
	デスクトップの画像をキャプチャーすることができます
	rikky_module.desk(number, number, number, number [, boolean or number])
	1番目と2番目はキャプチャーを始めるデスクトップのxとyの座標の数値です
	3番目と4番目はキャプチャーする横と縦の大きさの数値です、0を渡すとデスクトップのもともとの大きさになります
	5番目を省略した場合またはtrueまたは1を渡した場合は、マウスアイコンを含めます
	falseまたは0を渡した場合は、マウスアイコンは含まれません

mouse関数
	マウスの座標位置を取得できます
	number, number = rikky_module.mouse(string or number)
	引数がない場合は、メインウインドウに対してのマウスのx座標とy座標の2つの数値を返します
	"playwindow"の文字列の場合は、再生ウインドウに対してのマウスのx座標とy座標の2つの数値を返します
	"auto"の文字列の場合は、自動で再生をするウインドウを判定して、そのウインドウに対してのマウスのx座標とy座標の2つの数値を返します
	数値の場合は、その数値のウインドウハンドルのウインドウに対してのマウスのx座標とy座標の2つの数値を返します

image関数
	オブジェクトの画像データを一時保存できます
	第1引数で指定する文字列によって、書き、読み、消し、ID検索などが決定します
	第1引数の文字列
	"w"  : オブジェクトイメージをメモリに書き込みます
	       boolean = rikky_module.image("w", string or number [, string])
	       書き込みたいIDを文字列か数値で指定します
	       第3引数に"tempbuffer"を指定すると、仮想バッファのイメージを保存できます
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"w+" : オブジェクトイメージをメモリに書き込みます
	       boolean = rikky_module.image("w+", string or number)
	       書き込みたいIDを文字列か数値で指定します
	       透明度やobj.alphaの数値をイメージのアルファ値に乗算します
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"r"  : メモリ上にある書き込んだオブジェクトイメージを呼び出します
	       boolean = rikky_module.image("r", string or number)
	       呼び出したいIDを文字列か数値で指定します
	       成功するとtrue、失敗するとfalseのブ―リアンを返します
	       新しく呼び出しているのでobj.oxなどの値は初期化されます

	"r+" : メモリ上にある書き込んだオブジェクトイメージを呼び出します
	       boolean = rikky_module.image("r+", string or number)
	       呼び出したいIDを文字列か数値で指定します
	       成功するとtrue、失敗するとfalseのブ―リアンを返します
	       呼び出す前のobj.oxなどを引き継ぎます

	"c"  : メモリに書き込んだオブジェクトイメージを消去します
	       boolean = rikky_module.image("c", string or number)
	       消去したいIDを文字列か数値で指定します
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"c+" : メモリに書き込んだオブジェクトイメージを消去します
	       boolean = rikky_module.image("c+")
	       書き込んだすべてのイメージを消去します
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"g"  : 書き込まれていないID番号を取得する
	       number or talbe = rikky_module.image("g" [, number])
	       まだ使われていないIDの数値を返します
	       0以上の数値です
	       第2引数に0より大きい数値を渡すと、その分だけ未使用のID番号をテーブルで返します

	"g+" : 書き込まれているID番号を取得します
	       table = rikky_module.image("g+")
	       既に書き込まれているIDが収められたテーブルを返します

	"m"  : 書き込まれたイメージを合成します
	       userdata, number, number = rikky_module.image("m", string or number, string or number [, number, number])
	       第2引数で背面のイメージIDを指定し、第3引数で前面に来るイメージIDを指定します
	       第4引数はx座標の数値、第5引数y座標の数値を指定します
	       背面イメージの左上が0、0です
	       省略した場合は0、0と同じになります
	       合成結果はイメージのユーザーデータ、横幅の数値、縦幅の数値の3つを返します
	       ただし、合成に失敗した場合はfalseのブ―リアンを返します

	"m+" : 書き込まれたイメージを合成します
	       boolean = rikky_module.image("m+", string or number, string or number [, number, number])
	       合成をして、同時にそのイメージを読み込みます
	       読み込むときは"r+"と同じ処理になります
	       第2引数で背面のイメージIDを指定し、第3引数で前面に来るイメージIDを指定します
	       第4引数はx座標の数値、第5引数y座標の数値を指定します
	       背面イメージの左上が0、0です
	       省略した場合は0、0と同じになります
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"i"  : イメージデータ情報を取得します
	       userdata, number, number = rikky_module.image("i", string or number)
	       イメージ情報を取得したいIDを文字列か数値で指定します
	       戻り値はイメージのユーザーデータ、横幅の数値、縦幅の数値の3つを返します

	"i+" : イメージデータ情報を取得します
	       table, number, number = rikky_module.image("i+", string or number)
	       イメージ情報を取得したいIDを文字列か数値で指定します
	       戻り値はイメージのARGBの情報をもったテーブル、横幅の数値、縦幅の数値の3つを返します
	       テーブルのキーはA、R、G、Bの4つで、それぞれ0から255までの数値をピクセルの数だけ持っています

	"p"  : 指定したIDのイメージに別の指定したIDのイメージをコピーします
	       boolean = rikky_module.image("p", string or number, string or number or userdata, [ number, number])
	       第2引数はコピーイメージを置きたいID、第3引数はコピー元のIDを文字列か数値で指定します
	       第3引数をuserdataにした場合は、横幅を第4引数、縦幅を第5引数に渡してください
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"p+" : 指定したIDのイメージに別の指定したIDのイメージをコピーします
	       boolean = rikky_module.image("p+", string or number, string or number or userdata, [ number, number])
	       第2引数はコピーイメージを置きたいID、第3引数はコピー元のIDを文字列か数値で指定します
	       第3引数をuserdataにした場合は、横幅を第4引数、縦幅を第5引数に渡してください
	       コピー先に既にイメージがある場合は失敗になります
	       成功するとtrue、失敗するとfalseのブ―リアンを返します

	"u"  : 指定したIDまたは渡したuserdataの指定した位置の色と透明度を取得します
	       number, number = rikky_module.image("u", string or number or userdata, number [, number, number, number])
	       色の数値は0から0xFFFFFF、透明度は0から1です
	       IDを指定した場合とuserdataを指定した場合で引数が変わってきます
	       また取得したい色の位置の指定方法でも引数が変わってきます
	       IDを指定した場合、第3引数または第3引数と第4引数が色の位置を指定する部分になります
	       第3引数のみの場合はその数値の位置の色情報、第4引数も渡すと横と縦の位置の色情報を返すようになります
	       例えば10×10で第3引数のみ99だと右下の色情報、第3引数を10、第4引数を10にすると右下の色情報になります
	       userdataを指定したuserdataの縦幅と横幅を渡す必要があります
	       色の位置を1つの数値だけで指定する場合は第4引数に横幅、第5引数に縦幅の数値を渡します
	       色の位置を縦と横の位置で指定した場合は第5引数に横幅、第6引数に縦幅の数値を渡します

	"u+" : 指定したIDまたは渡したuserdataの指定した位置の色のRとGとBと透明度を取得します
	       number, number, number, number = rikky_module.image("u", string or number or userdata, number [, number, number, number])
	       色の数値はRが0から255、Gが0から255、Bが0から255、透明度は0から255です
	       IDを指定した場合とuserdataを指定した場合で引数が変わってきます
	       また取得したい色の位置の指定方法でも引数が変わってきます
	       IDを指定した場合、第3引数または第3引数と第4引数が色の位置を指定する部分になります
	       第3引数のみの場合はその数値の位置の色情報、第4引数も渡すと横と縦の位置の色情報を返すようになります
	       例えば10×10で第3引数のみ99だと右下の色情報、第3引数を10、第4引数を10にすると右下の色情報になります
	       userdataを指定したuserdataの縦幅と横幅を渡す必要があります
	       色の位置を1つの数値だけで指定する場合は第4引数に横幅、第5引数に縦幅の数値を渡します
	       色の位置を縦と横の位置で指定した場合は第5引数に横幅、第6引数に縦幅の数値を渡します

assign関数
	指定した文字列を変数にすることができます
	第1引数で処理内容が変わってきます
	"make" : 
		boolean = rikky_module.assign("make", string, string or number or boolean or table)
		第2引数に変数名にしたい文字列を指定します
		第3引数は変数に代入したい文字列や数値などを渡します
		成功するとtrue、失敗するとfalseのブ―リアンを返します

	"copy" : 
		string or number or boolean or table or nil = rikky_module.assign("make", string)
		第2引数に持っているデータを使いたい変数名の文字列を指定します
		戻り値はその変数が持っている数値や文字列などを返します

	変数名は先頭の文字が_か数字以外の英字である必要があります
	予約語である場合も設定できません
	予約語は以下の21種類です
	and、break、do、else
	elseif、end、false、for
	function、if、in、local
	nil、not、or、repeat
	return、then、true、until
	while
	luaでは大文字と小文字は別として扱われるのでORなどは予約語ではなく、変数名として使うことができます

convert関数
	文字列をShift-JIS以外の文字コードに変換できます
	string or table [, number] = rikky_module.convert(string or table, string [, string [, string]])
	第1引数が文字列の場合はテーブルとそのテーブルの要素数の数値の2つを返します
	第1引数がテーブルの場合は文字列を返します
	第2引数は変換するタイプを指定する文字列を指定します
	"shift-jis" : 第1引数がテーブルのときは、その要素をShift-JISの文字コードと認識して文字列に変換します、第1引数が文字列のときは、Shift-JISの文字コードが入ったテーブルを返します
	"unicode"   : 第1引数がテーブルのときは、その要素をunicodeの文字コードと認識して文字列に変換します、第1引数が文字列のときは、unicodeの文字コードが入ったテーブルを返します
	"utf8"      : 第1引数がテーブルのときは、その要素をutf8の文字コードと認識して文字列に変換します、第1引数が文字列のときは、utf8の文字コードが入ったテーブルを返します

	第3引数は"unicode"のときに第1引数のテーブルの要素を16進表記の文字列にするか数値にするかを決めるものです
	"hex"       : unicodeの数値が16進数表記の文字列になります、英語の部分は小文字になります
	"HEX"       : unicodeの数値が16進数表記の文字列になります、英語の部分は大文字になります
	その他      : unicodeの数値のままです

	第4引数は"unicode"で16進数を扱うときリトルエンディアンかビックエンディアンか決めるものです
	"big"       : 通常の16進数です、f00fならば61455の数値と表します
	"little"    : 上位バイトと下位バイトが入れ替わった形になります、f00fならば4080の数値を表します

	例
	local unicode, unicode_num = rikky_module.convert("あいうえお", "unicode")
	unicode_num : 5
	unicode : [12354, 12356, 12358, 12360, 12362]

	local unicode, unicode_num = rikky_module.convert("あいうえお", "unicode", "hex")
	unicode_num : 5
	unicode : ["3042", "3044", "3046", "3048", "304A"]

	local str = rikky_module.convert({2354, 12356, 12358, 12360, 12362}, "unicode")
	str : "あいうえお"

	local str = rikky_module.convert({"3042", "3044", "3046", "3048", "304A"}, "unicode", "hex")
	str : "あいうえお"


datasave関数
	グローバル変数をプロジェクトに書き込むことができます
	boolean = rikky_module.datasave(string)
	保存、書き込みたい変数名を引数に渡します
	書込みが可能になったらtrue、不可だったらfalseを返します
	ただし、書き込むタイミングはプロジェクトファイルを保存するタイミングなので、実際にはできていない可能性もあります
	スクリプトの先頭でこの関数は呼び出してください

textload関数
	obj.load("text", string)のように使える関数です
	違いは文字寄せや縦書などを指定できるかどうかです
	rikky_module.textload(string [, number, number, number, string, number])
	文字列は呼び出したい文字列を渡します
	第2引数はテキストを寄せる位置を指定します
	0が左、1が中央、2が右です
	第3引数は中心の位置を変更できます
	0が左上、1が真ん中上、2が右上
	3が左中央、4が真ん中中央、5が右中央
	6が左下、7が真ん中下、8が右下
	の9つのどれかです
	第4引数は横書きか縦書かを決めます
	1が縦書き、0が横書きです
	第5引数はフォントを指定できます
	第6引数はフォントのサイズを指定できます
	テキストオブジェクト内の個別オブジェクトで文字列を呼び出すとエラーを起こしますが
	これを使って呼び出すとエラーを出さずに呼び出すことができます

bordering関数
	オブジェクトイメージの輪郭の座標を取得できます
	table, table, number = rikky_module.bordering([number or string, number, number or boolean, number or boolean, number or boolean])
	戻り値は輪郭の座標位置が入ったテーブルと位置の入ったテーブルの各要素の数値の入ったテーブルと数値の入ったテーブルの総数の数値です
	つまり総数の数だけ輪郭があり、2番目のテーブルに各輪郭の位置の数があり、1番目のテーブルに位置のx座標やy座標の数値が入っています
	第1引数が数値のときはその数分だけ輪郭の位置の数を間引きます
	引数がない場合は間引かず、輪郭の位置などを返します
	第1引数が"pixel"のときは座標位置がpixel上の位置になります
	第2引数は輪郭境界のアルファ値のしきい値を設定できます
	0から100までです
	第3引数は拡大率を座標に反映させるかを決めるものです
	trueまたは1のときは反映するようになり、falseまたは0または設定しない場合は反映されません
	第4引数は回転を座標に反映させるかを決めるものです
	trueまたは1のときは反映するようになり、falseまたは0または設定しない場合は反映されません
	回転させると座標はz座標も加わるようになります
	ただし、pixelを指定しいる場合は回転や拡大率を反映されません
	通常は左回り(反時計回り)でなぞるようになっていますが、内側の場合は右回り(時計回り)になります
	第5引数はより細かく輪郭を測るようになります
	trueまたは1のとき有効になります

camerainfo関数
	カメラ制御のパラメータに加えて、通常では取得できない情報も取得できます
	table = rikky_module.camerainfo([table])
	引数は省略可能です
	引数に渡すテーブルは、以下のいずれかです
	obj.draw関数と同じ引数またはobj.drawpoly関数と同じ引数です
	これはobj.draw関数などで描画したときの位置情報をもとにカメラデータなどを取得したい場合に指定します
	戻り値のテーブルには以下のキーが存在しています
	x            : カメラのx座標の数値
	y            : カメラのy座標の数値
	z            : カメラのz座標の数値
	tx           : カメラの焦点のx座標の数値
	ty           : カメラの焦点のy座標の数値
	tz           : カメラの焦点のz座標の数値
	ux           : カメラの上の向きのベクトルのx成分の数値
	uy           : カメラの上の向きのベクトルのy成分の数値
	uz           : カメラの上の向きのベクトルのz成分の数値
	ex           : カメラの焦点の向きのベクトルのx成分の数値
	ey           : カメラの焦点の向きのベクトルのy成分の数値
	ez           : カメラの焦点の向きのベクトルのz成分の数値
	nx           : カメラの横の向きのベクトルのx成分の数値
	ny           : カメラの横の向きのベクトルのy成分の数値
	nz           : カメラの横の向きのベクトルのz成分の数値
	rz           : カメラの回転角度のラジアンの数値
	d            : 視野角の距離の数値
	blur         : カメラの深度ぼけの現在の数値
	normal_d     : オブジェクトとカメラが作る面との距離の数値
	real_d       : オブジェクトとカメラとの距離の数値
	vx           : カメラからオブジェクトへと向かうベクトルのx成分の数値
	vy           : カメラからオブジェクトへと向かうベクトルのy成分の数値
	vz           : カメラからオブジェクトへと向かうベクトルのz成分の数値
	mx           : オブジェクトの正面が向いているベクトルのx成分の数値
	my           : オブジェクトの正面が向いているベクトルのy成分の数値
	mz           : オブジェクトの正面が向いているベクトルのz成分の数値
	ax           : オブジェクトの面の横向きのベクトルのx成分の数値
	ay           : オブジェクトの面の横向きのベクトルのy成分の数値
	az           : オブジェクトの面の横向きのベクトルのz成分の数値
	ix           : オブジェクトのAviutlの画面上での見かけ上のx座標の数値
	iy           : オブジェクトのAviutlの画面上での見かけ上のy座標の数値
	zoom         : オブジェクトのAviutlの画面上での見かけ上の倍率の数値
	shadow_x     : シャドーの光源のx座標の数値
	shadow_y     : シャドーの光源のy座標の数値
	shadow_z     : シャドーの光源のz座標の数値
	shadow_accu  : シャドーの光源の精度の数値
	shadow_conce : シャドーの光源の濃度の数値
	shadow_flag  : シャドーが有効なら1、無効なら0の数値
	billboard    : カメラの方向を向くかの数値(getinfo("billboard")で取得できる数値と同じ)

audiobuffer関数
	obj.getaudioよりも詳しく複雑にいろいろすることができます
	table [, table] = rikky_module.audiobuffer(number [, string, string, string, number, number, table])
	第1引数は音声を取得したいフレーム数を指定する数値です
	取得するタイプによってフレーム数が現在の位置から相対的な位置なのか、プロジェクト全体の絶対的な位置なのかを決めることができます
	第2引数は取得する波形の種類を決める文字列です
	"PCM"      : 音の波の形を時間で表したものです(サイン波のようなうねうねしたものです)
	"FOURIER"  : PCM波形をフーリエ変換して周波数の強さを表したものです
	"SPECTRUM" : PCM波形をフーリエ変換したものを見やすく対数表で表したものです
	"DESIBEL"  : 基準音からのパワーの強さの割合で、大きいほど0に近づき、小さいほどマイナスになります
		ただし、パワーが0のとき(無音)はデシベルが-∞になって数値では表現できないので、nilが入るようになります

	第3引数はフレーム数が相対的か絶対的かを決める文字列です
	"relative" : 常に今のフレーム数からの相対的なフレーム数の音声を取得するようになります
	"absolute" : プロジェクトの指定したフレーム数の音声を取得するようになります

	第4引数は戻り値を1つにするか2つにするかを決める文字列です
	"stereo"   : 左右それぞれの音声波形を取得するようになります
	"monaural" : 左右の音の平均の音声波形を取得するようになります

	第5引数は取得するテーブルの要素数を決める数値です
	波形の種類によってサイズの上限があります
	"PCM"の場合は、サンプル周波数 / フレームレート数の値です
	"FOURIER"と"DECIBEL"の場合は、サイズ指定できません
	"SPECTRUM"の場合は、フーリエ変換したときのデータ数です
	チャンネル数の数値とサンプリング数の数値を返します

	第6引数は分解能を決める数値です
	フーリエ変換をする際の細かさのことで、0,1,2,3のいずれかを指定します
	わかり易く説明するとサンプル周波数が44100だとすると分解能が1の場合
	1データ当たり44100/2048でおよそ21.5Hzごとに周波数を区切って計算することになります
	22Hzの音と23Hzの音などは同じ音として見なされて、43Hzとして扱われます
	あんまりよくわからないと思いますが基本のラ音は440Hzでラ♯は466.2Hzなのでこの分解能だと同じ音として扱われます
	要は計算が軽い代わりに音の区別があいまいになるということです
	0は分解能1024です、細かさはおよそ43Hz
	1は分解能2048です、細かさはおよそ21.5Hz
	2は分解能4096です、細かさはおよそ10.7Hz
	3は分解能8192です、細かさはおよそ5.3Hz
	分解能の半分の値がフーリエ変換したときの得られるデータ数になります

	第7引数は"FOURIER"や"SPECTRUM"や"DECIBEL"で取得する範囲を指定するテーブルです
	{下限値、上限値}のように指定します
	下限値、上限値ともに周波数の数値を指定します
	指定できる数値の範囲は0からサンプル周波数の半分(いわゆるナイキスト周波数)です
	この範囲を指定すると"FOURIER"と"DECIBEL"のサイズも変化します
	"SPECTRUM"はこの範囲内でsize分だけ分割されます
	戻り値は左側と右側の音声波形のテーブルです
	第4引数が"monaural"の場合は1つだけになります
	引数をなしで呼び出すと
	number, number = rikky_module.audiobuffer()
	チャンネル数とサンプル周波数の数値2つを返します

colorconvert関数
	色をさまざまなカラーコードに変換することができます
	変換できるカラーコードは全てで10種類です
	RGB           : 第1引数に"rgb"の文字列を指定します
			number, number, number = rikky_module.colorconvert("rgb", number)
			第2引数に数値の色を指定すると、RGBに対応したR、G、Bの数値3つを返します
			number = rikky_module.colorconvert("rgb", number, number, number)
			第2引数から第4引数までにRGBのR、G、Bを指定すると数値の色の数値を返します
			各成分の上下限はR[0, 255]、G[0, 255]、B[0, 255]

	ycbcr         : 第1引数に"yc"の文字列を指定します
			number, number, number = rikky_module.colorconvert("yc", number)
			第2引数に数値の色を指定すると、ycbcrに対応したy、cb、crの数値3つを返します
			number = rikky_module.colorconvert("yc", number, number, number)
			第2引数から第4引数までにycbcrのy、cb、crを指定すると数値の色の数値を返します
			各成分の上下限はy[0, 4096]、cb[-2048, 2048]、cr[-2048,2048]

	HSV           : 第1引数に"hsv"の文字列を指定します
			number, number, number = rikky_module.colorconvert("hsv", number)
			第2引数に数値の色を指定すると、HSVに対応したH、S、Vの数値3つを返します
			number = rikky_module.colorconvert("hsv", number, number, number)
			第2引数から第4引数までにHSVのH、S、Vを指定すると数値の色の数値を返します
			各成分の上下限はH[0, 360]、S[0, 100]、V[0, 100]

	HSL           : 第1引数に"hsl"の文字列を指定します
			number, number, number = rikky_module.colorconvert("hsl", number)
			第2引数に数値の色を指定すると、HSLに対応したH、S、Lの数値3つを返します
			number = rikky_module.colorconvert("hsl", number, number, number)
			第2引数から第4引数までにHSLのH、S、Lを指定すると数値の色の数値を返します
			各成分の上下限はH[0, 360]、S[0, 100]、L[0, 100]

	xyz           : 第1引数に"xyz"の文字列を指定します
			number, number, number = rikky_module.colorconvert("xyz", number)
			第2引数に数値の色を指定すると、xyzに対応したx、y、zの数値3つを返します
			number = rikky_module.colorconvert("xyz", number, number, number)
			第2引数から第4引数までにxyzのx、y、zを指定すると数値の色の数値を返します
			各成分の上下限はx[0, 95]、y[0, 100]、z[0, 109]

	L*a*b*        : 第1引数に"lab"の文字列を指定します
			number, number, number = rikky_module.colorconvert("lab", number)
			第2引数に数値の色を指定すると、L*a*b*に対応したl*、a*、b*の数値3つを返します
			number = rikky_module.colorconvert("lab", number, number, number)
			第2引数から第4引数までにL*a*b*のl*、a*、b*を指定すると数値の色の数値を返します
			各成分の上下限はL*[0, 100]、a*[-86, 98]、b*[-108, 94]

	CMY           : 第1引数に"cmy"の文字列を指定します
			number, number, number = rikky_module.colorconvert("cmy", number)
			第2引数に数値の色を指定すると、CMYに対応したC、M、Yの数値3つを返します
			number = rikky_module.colorconvert("cmy", number, number, number)
			第2引数から第4引数までにCMYのC、M、Yを指定すると数値の色の数値を返します
			各成分の上下限はC[0, 100]、M[0, 100]、Y[0, 100]

	CMYK          : 第1引数に"cmyk"の文字列を指定します
			number, number, number, number = rikky_module.colorconvert("cmyk", number)
			第2引数に数値の色を指定すると、CMYKに対応したC、M、Y、Kの数値4つを返します
			number = rikky_module.colorconvert("cmyk", number, number, number, number)
			第2引数から第5引数までにCMYKのC、M、Y、Kを指定すると数値の色の数値を返します
			各成分の上下限はC[0, 100]、M[0, 100]、Y[0, 100]、K[0, 100]

	complementary : 第1引数に"complemntary"の文字列を指定します
			number = rikky_module.colorconvert("complemntary", number)
			第2引数に数値の色を指定すると、その色の補色の数値を返します

	opposite      : 第1引数に"opposite"の文字列を指定します
			number = rikky_module.colorconvert("opposite", number)
			第2引数に数値の色を指定すると、その色の反対色の数値を返します

rotation関数
	任意の座標を任意の角度、軸で回転させることができます
	number, number, number = rikky_module.rotation(number, number, number [, number, string or table, table])
	第1引数から第3引数までは回転させたいx座標、y座標、z座標の数値を渡します
	第4引数は回転させる角度の数値(ラジアン)です

	第5引数は回転させる軸を指定するものです
	"X"      : X軸で回転させます
	"Y"      : Y軸で回転させます
	"Z"      : Z軸で回転させます
	テーブル : 規格化されたベクトル{x成分、y成分、z成分}を軸にして回転させます

	第6引数は回転させる中心点です
	{xの位置、yの位置、zの位置}のように指定します
	座標の3つだけを引数で渡すと、1つ前で渡した回転角度、軸、中心で回転します

axisconvert関数
	AviUtl固有の軸回転でも任意の軸回転ができるような回転角度を取得することができます
	number, number, number = rikky_module.axisconvert(table [, number])
	引数のテーブルは12個のキーを用意します
	Xx : X軸のx成分の数値
	Xy : X軸のy成分の数値
	Xz : X軸のz成分の数値
	rx : X軸で回転させる角度の数値
	Yx : Y軸のx成分の数値
	Yy : Y軸のy成分の数値
	Yz : Y軸のz成分の数値
	ry : Y軸で回転させる角度の数値
	Zx : Z軸のx成分の数値
	Zy : Z軸のy成分の数値
	Zz : Z軸のz成分の数値
	rz : Z軸で回転させる角度の数値
	3つの直交軸を規格化した3成分ずつで表すことで、その軸に対して回転をさせます
	角度は度数法の数値ですが、第2引数を1にすると弧度法で数値指定できるようになります
	戻り値はその回転をAviUtlで表現するためのX軸の回転角度、Y軸の回転角度、Z軸の回転角度の数値3つです
	ここも第2引数が1の場合は、度数法ではなく弧度法の数値を返すようになります
	この関数はつまり、ユーザー自身が回転させたい軸で回転させた表現ををAviUtlのX軸回転、Y軸回転、Z軸回転で表現するための回転角度を返すものです

axisconvertEx関数
	AviUtl固有の軸回転でも任意の軸回転ができるような回転角度を取得することができます
	axisconvert関数の発展版です
	number, number, number = rikky_module.axisconvertEx(table [, number, number])
	引数のテーブルは回転させる軸のx成分の数値、y成分の数値、z成分の数値、回転させる角度の数値の4つを1組として順々に回転させたい数だけ収めていきます
	軸の成分は規格化したベクトルが望ましいです
	例えば2度回転させる場合は、{x0, y0, z0, r0, x1, y1, z1, r1}を引数に渡します
	第2引数は回転角度を決める数値です
	0ならば度数法、1ならば弧度法です
	第3引数は回転した場合、全ての後続の回転軸もその回転によって回転するかを決めるものです
	0ならば軸はそのまま、1ならば回転に合わせて全ての後続の回転軸も回転します
	例えば{x0, y0, z0, r0, x1, y1, z1, r1}で回転をすると、x1、y1、z1がx0、y0、z0軸でr0分だけ回転した結果がx1、y1、z1に上書きされます
	また引数のテーブルには初期のX軸とY軸を設定することも可能です
	それぞれ軸は以下のキーで設定します
	Xx : X軸のx成分の数値
	Xy : X軸のy成分の数値
	Xz : X軸のz成分の数値
	Yx : Y軸のx成分の数値
	Yy : Y軸のy成分の数値
	Yz : Y軸のz成分の数値
	Z軸が設定できないのは、X軸とY軸が定まれば自動的にZ軸が定まるからです

setdialogparam関数
	パラメータ設定ウインドウの数値を自由に変更することもできます
	rikky_module.setdialogparam(string, string or number or boolean or table)
	第1引数はアニメーション効果などの--dialogで設定する変数名の文字列です
	この変数名はグローバル変数でなければなりません
	第2引数はその変数に反映させたい数値や文字列などです
	これを指定すれば、パラメータ設定ウインドウの数値なども変更されます
	ダイアログ数値設定とはそもそも何かといえば、obj.setanchorでダイアログの数値が画面のアンカーを動かすと変化するように
	自動的にダイアログ設定の数値を変更することができるものです

glassdraw_init関数
glassdraw関数
	ガラスで屈折するように描画することができます
	glassdraw_init関数で初期化と設定をして、glassdraw関数で描画をします
	rikky_module.glassdraw_inti(table)
	引数のテーブルにさまざまなキーを設定します
	color       : 屈折して表示するイメージを単色化させる色の数値
	reverse     : 上下左右反転を有効ならば1、無効ならば0の数値
	reverseUp   : 上下反転を有効ならば1、無効ならば0の数値
	reverseSide : 左右反転を有効ならば1、無効ならば0の数値
	blur        : ぼかす範囲の数値
	refractive  : 0から1までの屈折率の数値
	offsetZ     : フレームバッファまでの仮想的な高さの数値
	boundary    : 屈折する光が四隅、四辺を超えたときの処理の仕方を決める文字列
		      "loop"     : 境界までくると反対側からループしてような処理になります
		      "inverted" : 境界より先はイメージが反転した処理になります
		      設定なし   : 境界の色を引き延ばした処理になります
	async       : 取得する背景を同期するならば1、しない場合は0の数値
	culling     : 裏面を非表示にするならば1、しない場合は0の数値
	zoom        : 映し出す画像を拡大縮小させるときに設定する数値で、1だと等倍、2だと2倍のようになります
	lens        : ガラスの面に凹凸を決める文字列
		      "convex"  : 凸レンズ気味に映し出されるようになります
		      "concave" : 凹レンズ気味に映し出されるようになります
	各キーは必要なものだけ設定することも可能です
	つまり常にこれらのキーに数値や文字列を指定する必要がないわけです
	glassdraw_inti関数で設定して、glassdraw関数で描画する間にobj.loadなど新しくイメージを読み込む処理をすると思わぬ事態になるかもしれません
	obj.loadなどは使わないようにしてください
	rikky_module.glassdraw関数で描画します
	引数はobj.drawかobj.drawployと同じようにx座標などを渡します
	どちらになるかは引数の数で自動で判断します

materialdraw_init関数
materialdraw関数
	光源があるかのように描画することができます
	materialdraw_init関数で初期化と設定をして、materialdraw関数で描画していきます
	rikky_module.materialdraw_init(table)
	引数のテーブルにさまざまなキーを設定します
	lignt_num : 用意する光源の数の数値、最大で4まで指定可能です
	position1 : 1つ目の光源の位置を座標をもったテーブル
	position2 : 2つ目の光源の位置を座標をもったテーブル
	position3 : 3つ目の光源の位置を座標をもったテーブル
	position4 : 4つ目の光源の位置を座標をもったテーブル
		    position系のテーブルには4つのキーを指定できます
		    x      : 光源のある位置のx座標の数値
		    y      : 光源のある位置のy座標の数値
		    z      : 光源のある位置のz座標の数値
		    object : 特定のものを光源にするための文字列
			     "shadow"              : カメラ制御のシャドー効果の光源の位置の数値を用いるようになります
			     "camera"              : カメラ制御のカメラの位置の数値を用いるようになります
			     "L1から100までの数値" : 指定した数値のレイヤにあるオブジェクトの位置の数値を用いるようになります
						     ただし、その位置にオブジェクトがない場合は無効になりxやyやzで指定したキーの数値の位置になります
						     例として、50レイヤにあるオブジェクトの位置を光源に用いる場合は"L50"の文字列を指定します
			     指定なし              : xやyやzで指定したキーの数値の位置になります
	light1   : 1つ目の光源の色情報をもったテーブル
	light2   : 2つ目の光源の色情報をもったテーブル
	light3   : 3つ目の光源の色情報をもったテーブル
	light4   : 4つ目の光源の色情報をもったテーブル
		   light系のテーブルには3つのキーを指定できます
		   R : R(赤系)の0から255までの数値
		   G : G(緑系)の0から255までの数値
		   B : B(青系)の0から255までの数値
	ambient  : 環境色を設定するテーブル、3つのキーを指定できます
		   R : R(赤系)の0から100までの数値
		   G : G(緑系)の0から100までの数値
		   B : B(青系)の0から100までの数値
	emissive : 元のオブジェクトのRGB値に加える色味のテーブル、3つのキーを指定できます
		   R : R(赤系)の0から255までの数値
		   G : G(緑系)の0から255までの数値
		   B : B(青系)の0から255までの数値
	specular : 鏡面反射する色身のテーブル、4つのキーを指定できます
		   R         : R(赤系)の0から255までの数値
		   G         : G(緑系)の0から255までの数値
		   B         : B(青系)の0から255までの数値
		   shininess : ハイライトのシュッとする感じを決める数値
	各キーは必要なものだけ設定することも可能です
	つまり常にこれらのキーに数値や文字列を指定する必要がないわけです
	メモリには直前に使った設定が残っているので、予想と違うことになる場合があります
	その場合は設定する前に、materialdraw_init(0)と0を引数に渡して、すべてを初期化させることも可能です
	materialdraw_inti関数で設定して、materialdraw関数で描画する間にobj.loadなど新しくイメージを読み込む処理をすると思わぬ事態になるかもしれません
	obj.loadなどは使わないようにしてください
	rikky_module.materialdraw関数で描画します
	引数はobj.drawかobj.drawployと同じようにx座標などを渡します
	どちらになるかは引数の数で自動で判断します

materialdrawEx関数
	光源があるかのように描画することができます
	materialdraw関数とmaterialdraw_init関数を合わせて強化した関数です
	オブジェクト指向的な使い方をします
	material = rikky_module.materialdrawEx(table)
	このように光源の情報を含んだtableを引数に渡すとその状態を保持したmaterialが返ってきます
	描画する際はmaterial:draw()かmaterial:drawpoly()のように使います
	通常のobj.drawやobj.drawpolyと同じように位置や角度などの引数を渡すだけです
	ピリオド(.)ではなくコロン(:)なので、注意してください
	materialdrawEx関数に渡すtableは以下のようにいくつかのキーを設定します
	table = {
	  ambient = {R = number, G = number, B = number},
	  emissive = {R = number, G = number, B = number},
	  damping = number,
	  drawhq = boolean,
	  drawhq_partition = number,
	  light = {
	    {
	      color = {R = number, G = number, B = number},
	      specular = {R = number, G = number, B = number, shininess = number},
	      position = {x = number, y = number, z = number} or string or number,
	      option = {
	        type = string,
	        nx = number,
	        ny = number,
	        nz = number,
	        degree = number,
	        double = boolean,
	        degree2 = number,
	        nx2 = number,
	        ny2 = number,
	        nz2 = number,
	        texture = string or number,
	        wx = number,
	        wy = number,
	        wz = number,
	        partition = number,
	        width = number,
	        height = number,
	      }
	    },
	    {
	    --設定したい分だけライトの情報を記述します
	    },.....
	  }
	}
	tableのキーとその値のデータ型は上記のようになっています
	optionはtypeによって設定するキーが異なってきます
	一部、materialdraw関数と同名のキーでもニュアンスが異なるものがあります
	ambient          : 全体を照らす光で、マテリアルの色の底上げのように使い、RGBは0から255で色を指定します
	emissive         : マテリアル自体の発光度合いで、0から100で指定します
	damping          : 光は距離の逆二乗で減衰していきます、それの度合いの数値です、0の場合は減衰は起きません
	drawhq           : material:draw関数を使用した際により正確に描画するためのものです
	drawhq_partition : drawhqを有効かした際に、正確さの細かさです、drawhqが有効でもこれを設定していない場合drawhqは無効になります
	light            : 光源になるライトを設定します、ライトは何個も設定できます
	color            : ライトの色を設定します、RGBは0から255で各色を設定します
	specular         : 鏡面反射する強度を設定します0以上の数値を設定できます、RGBは各成分の強度で、shininessはハイライトの大きさで、数値が大きいほどシャープになります
	position         : ライトの位置を設定しますxyzで数値を設定するか、文字列で"camera"だとカメラの位置、"shadow"だとカメラ制御の光源の位置です、数値だとそのレイヤのオブジェクトの位置になります、"@数値"だと相対的にレイヤを指定できます
	option           : ライトのタイプを変える際に用いります、optionがなければライトは点光源になります
	type             : "spotlight"または"directlight"のどちらかが使えます、"spotlight"だと点光源に帽子をかぶせたようになり、"directlight"は面光源に切り替えられます
	nx               : "spotlight"や"directlight"の光の進むベクトルのx方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の向きのx成分になります
	ny               : "spotlight"や"directlight"の光の進むベクトルのy方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の向きのy成分になります
	ny               : "spotlight"や"directlight"の光の進むベクトルのz方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の向きのz成分になります
	degree           : "spotlight"や"directlight"の光の広がりの角度で0から90度までです
	double           : "spotlight"や"directlight"の背面からも光を出るようにします
	degree2          : "spotlight"かつ背面の光が有効のときの光の広がりの角度で0から90度までです
	nx2              : "spotlight"かつ背面の光が有効のときの光の進むベクトルのx方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の裏側の向きのx成分になります
	ny2              : "spotlight"かつ背面の光が有効のときの光の進むベクトルのy方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の裏側の向きのy成分になります
	ny2              : "spotlight"かつ背面の光が有効のときの光の進むベクトルのz方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの面の裏側の向きのz成分になります
	texture          : "directlight"の光を指定します、数値だとそのレイヤの画像、文字列"@数値"だと相対的に指定したレイヤ画像、文字列"color"だとライトのcolorで指定した色、*画像のパス(画像パスの先頭にアスタリスクをつけた文字列)だとその画像が光源になります
	wx               : "directlight"の面の横向きのベクトルのx方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの横の向きのx成分になります
	wy               : "directlight"の面の横向きのベクトルのy方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの横の向きのy成分になります
	wz               : "directlight"の面の横向きのベクトルのz方向の成分を指定します、ただしpositionでレイヤを指定している場合はそのオブジェクトの横の向きのz成分になります
	partition        : "directlight"でレイヤもしくは画像をtextureで指定した場合にその光源の細かさを設定する数値です、小さいと重たくなります
	width            : "directlight"でcolorのtextureを指定した場合にその面光源の横幅を指定する数値です、レイヤかパスによる画像を指定している場合にこの数値を設定するとこの横幅にリサイズされます
	height           : "directlight"でcolorのtextureを指定した場合にその面光源の縦幅を指定する数値です、レイヤかパスによる画像を指定している場合にこの数値を設定するとこの縦幅にリサイズされます

reloadbuffer関数
	audiobuffer関数のフレームバッファ取得版のようなものです
	拡張編集のバージョンが91e4以上でないと使えません
	指定したフレーム番号のフレームバッファを取得できます
	また指定したフレームの処理を行うことも可能です
	(userdata, number, number) or boolean or nil = rikky_module.reloadbuffer([number [[, string, boolean, string or table, boolean]])
	第1引数は取得したいフレーム数を指定します、第2引数によって意味合いが変わります

	第2引数は取得するフレーム数を絶対的に指定するか決めるものです
	例として取得するフレーム数を0として相対的な場合はオブジェクトの0フレーム目をリロードし、絶対的だとオブジェクトの位置に関わらず常にプロジェクトの0フレーム目をリロードします
		"absolute" : 取得するフレーム数を絶対的に指定します
		その他     : nilなど指定しすれば相対的にフレーム数を指定できます

	第3引数は戻り値を返すか決めるものです
	返ってきたuserdataはフレームバッファのピクセルデータです
	ただし、リロード中の場合は画面サイズの透明のイメージです
		true  : userdataと横幅、縦幅の数値を返すようにします
		false : nilを返します

	第4引数はリロード中に有効または無効にするレイヤを指定するものです
		table   : テーブル内で指定したレイヤ番号を非表示にしてリロードします
		"self"  : 関数を使うオブジェクトのレイヤ以外を非表示にしてリロードします
		"other" : 関数を使うオブジェクトのレイヤを非表示にしてリロードします

	第5引数は第4引数の非表示を表示するの意味合いに切り替えます
		true  : 非表示を表示に切り替えます
		flase : 通常通りです

	引数なしの場合は再読込中かを知ることができます
	boolean = rikky_module.reloadbuffer()
	trueのときは再読込中で、falseのときは通常処理中です

	使い方としては、現在のフレームよりも前または先のフレームバッファを取得したり、上のレイヤの処理を先にするためなどです
	例えばrikky_module.reloadbuffer(0)を実行した場合、一度現在のフレームのすべてのレイヤを処理した状態になって関数を終了します
	A=10
	※1
	rikky_module.reloadbuffer(0)
	※2
	A=20
	とした場合、rikky_module.reloadbuffer(0)の直前(※1の位置)のAの値は10、直後(※2の位置)の値は20になります
	つまり一度A=20を実行して関数を終了して、A=20を再び実行することになります
	書き方次第ではimage関数と組み合わせて、前フレームや次フレームのオブジェクトのイメージを取得することができます
	カメラ制御下でカメラ制御下のフレームを再読込すると、正しく描画されません

checkbox関数
	file関数やlist関数のように使い、設定ダイアログにチェックボックスを追加する関数です
	アニメーション効果で使ってください
	rikky_module.checkbox(number [, ...])
	設定ダイアログには最大でチェックボックスが4つまでしか設定できません
	それ以上設定するために用いります
	チェックボックス化したい設定ダイアログの項目の番号を複数引数として渡します
	例えば1番目と10番目の項目をチェックボックス化したい場合は以下のようにします
	rikky_module.checkbox(1, 10)
	初期値でチェックをつけたい場合は1、外したい場合は0を設定します
	--dialog:チェック,c=1
	rikky_module.checkbox(1)
	上記の場合はチェックがついた状態になります

colordialog関数
	file関数やlist関数のように使い、設定ダイアログに色選択ダイアログを出現させるボタンを追加する関数です
	アニメーション効果で使ってください
	rikky_module.colordialog(number [, table [, number, table ...]])
	設定ダイアログには最大で色ダイアログが4つまでしか設定できません
	それ以上設定するために用いります
	色ダイアログを追加したい設定ダイアログの項目の番号を複数引数として渡します
	またその番号の数値の次の引数に色ダイアログのパレットとして表示したい32色を追加することができます
	例えば1番目と10番目の項目に色ダイアログのボタンを出したい場合は以下のようにします
	local palette = {
		0xFFFFFF,0xCCCCCC,0xA8A8A8,0x808080,
		0xFF0000,0x00FFBF,0x00D4FF,0xFF003F,
		0xFF3F00,0x00FF7F,0x00BFFF,0xFF007F,
		0xFF7F00,0x00FF3F,0x007FFF,0xFF00BF,
		0xFFBF00,0x00FF00,0x003FFF,0xFF00FF,
		0xFFFF00,0x3FFF00,0x0000FF,0xBF00FF,
		0xBFFF00,0x7FFF00,0x3F00FF,0x7F00FF,
		0x808080,0x4C4C4C,0x333333,0x000000
	}
	rikky_module.colordialog(1, 10, palette)
	上記のようにすれば10番目の項目の色ダイアログはpalette変数で指定したオリジナルのパレットを使うことができます
	color_palette.aufに対応しているので、こちらのカラーパレットも使うことができます

parameter関数
	設定ダイアログにさらに専用のダイアログ(ウインドウ)を用意して数値を設定することができるようになる関数です
	アニメーション効果で使ってください
	... = rikky_module.parameter(string, number, table)
	戻り値は設定したtableの中身によって変わってきます
	設定した項目の数だけ戻り値があります
	第1引数は設定ダイアログで用意した文字列を指定します
	第2引数は第1引数の文字列が設定ダイアログの上から何番目かを指定するものです
	第3引数は専用ダイアログの設定を記したテーブルです
	使用例
	--dialog:専用ダイアログ,val="";
	local dia = {"変数", "0", -100, 100}
	local num = rikky_module.parameter(val, 1, dia)
	専用ダイアログの文字列は空文字を指定します
	このvalは1番目の項目なので1を第2引数に渡します
	daiはまず項目名の文字列、初期値の文字列、最小値、最大値を設定します
	4つのデータで1つの項目をなします
	dia = {"オンオフ", "true", 0, 0, "文字", "\"abc\"", 0, 0}
	boolean, string = rikky_module.parameter(val, 1, dai)
	とすると、チェックボックスの結果と文字列を返すようになります
	数値以外は最大値と最小値はないので、0を指定します
	文字列の項目名に*fileをつけるとファイル選択ができるようになります
	文字列の項目名に*folderをつけるとフォルダ選択ができるようになります
	文字列の項目名に*fontをつけるとフォント選択ができるようになります
	数値の項目名に*0.001など付けるとその細かさで数値を指定できるようになります
	最大で0.001刻みまで設定可能です。
	例としては
	dia = {"細かさ*0.01", "10", 0, 100, "パス*file", "\"abc\"", 0, 0}
	のようにします
	チェックボックスを用意する場合は初期値を"true"または"false"にします
	文字列にする場合は"\"\""と\"で挟むようにします
	テーブルの場合は"{}"とします
	aviutlのもともとのダイアログのようにどの型でも対応させる場合は
	dia = {"項目", "0", 0, 0}
	と初期値の文字列を"0"、最大値も最小値も0にします
	最大値と最小値を0にして、項目名に*colorをつけると色選択ができるようになります

ObjectOrientFigure関数
	obj.load関数で図形を呼び出すことをオブジェクト指向的に行えるようになるお遊び的なものです
	object = rikky_module.ObjectOrientFigure([number])
	返されたオブジェクトにいくつかの関数があるのでそれでサイズや図形の形、色などを設定します
	第1引数に数値をいれると初めから図形の形を設定できます、のちに説明するobject:SetFigure(number)を初期化と同時に行うイメージです
	ちなみに返されたオブジェクトが保持している関数のことをメソッドと呼びます
	メソッドは以下の数だけ用意しています
	Draw         : 描画するためのもので、object:Draw()のように使います
	SetFigure    : 描画する図形の形を決めるもので、object:SetFigure(number)のように使います、0が背景、1が円、2が星型、3が三角形、4が四角形、5が五角形、6が六角形です
	GetFigure    : 図形の形の数値を返すもので、number = object:GetFigure()のように使います、0が背景、1が円、2が星型、3が三角形、4が四角形、5が五角形、6が六角形です
	SetFigureStr : 描画する図形の形を決めるもので、object:SetFigureStr(string)のように使います、背景、円、星型、三角形、四角形、五角形、六角形のいずれかです
	GetFigureStr : 図形の形の数値を返すもので、string = object:GetFigureStr()のように使います、背景、円、星型、三角形、四角形、五角形、六角形のいずれかです
	SetSize      : 描画する図形のサイズを決めるもので、object:SetLine(number)のように使います
	GetSize      : サイズの数値を返すもので、number = object:GetSize()のように使います
	SetColor     : 描画する図形の色を決めるもので、object:SetColor(number)のように使います
	GetColor     : 色の数値を返すもので、number = object:GetColor()のように使います
	SetRGB       : 描画する図形の色をRGBの3つの数値で決めるもので、object:SetRGB(number, number, number)のように使います
	GetRGB       : 色のR、G、Bの3つの数値を返すもので、number, number, number = object:GetRGB()のように使います
	SetLine      : 描画する図形のライン幅を決めるもので、object:SetLine(number)のように使います
	GetLine      : ライン幅の数値を返すもので、number = object:GetLine()のように使います
	SetZoom      : 描画する図形の拡大率を決めるもので、object:SetZoom(number)のように使います、100が等倍、200が2倍とパーセント形式で数値を指定します
	GetZoom      : 拡大率の数値を返すもので、number = object:GetZoom()のように使います、100が等倍、200が2倍とパーセント形式で返します
	SetAlpha     : 描画する図形の不透過率を決めるもので、object:SetAlpha(number)のように使います、100が透過なし、0が透明化になります
	GetAlpha     : 不透過率の数値を返すもので、number = object:GetAlpha()のように使います、100が透過なし、0が透明化になります
	SetPos       : 描画する図形の位置xyzを3つの数値で決めるもので、object:SetPos(number, number, number)のように使います
	GetPos       : 位置の数値を返すもので、number, number, number = object:GetPos()のように使います
	ShiftPos     : 現在の位置から指定した数値分だけ位置を増減させる為に使うもので、object:ShiftPos(number, number, number)のように使います
	SetAngle     : 描画する図形の角度xyzを3つの数値で決めるもので、object:SetAngle(number, number, number)のように使います
	GetAngle     : 角度の数値を返すもので、number, number, number = object:GetAngle()のように使います
	ShiftAngle   : 現在の角度から指定した数値分だけ角度を増減させる為に使うもので、object:ShiftAngle(number, number, number)のように使います
	SetEffect    : 描画する図形にフィルタをかける為に使うもので、object:SetEffect(string, string, number or string, ...)のように使います、フィルタ名やフィルタ項目名など各自調べてください
	GetEffect    : かかるフィルタを返すもので、table = object:GetEffect()のように使います、テーブル内に複数のテーブルが入っていて、その個々のテーブルにフィルタ名やフィルタ項目名、数値が順々に入っています
	ClearEffect  : セットしたフィルタをすべて消去する為のもので、object:ClearEffect()のように使います
	RemoveEffect : 指定した順番のフィルタだけを削除する為のもので、object:RemoveEffect(number)のように使います
	Copy         : 同じオブジェクトを返すもので、object2 = object:Copy()のように使います

	例として
	local fig = rikky_module.ObjectOrientFigure()
	fig:SetPos(100, -100, 0)
	fig:SetColor(0xFFFF00)
	fig:SetSize(200)
	fig:SetFigure(1)
	fig:SetEffect("縁取り", "サイズ", 4, "color", 0xFF)
	fig:Draw()
	こうすると縁取りのフィルタがかかったサイズ200、黄色の円が位置100、-200、0の位置に描画されます
	元々の呼び出したオブジェクトはそのままであり、描画したことになっていないので、そのままだと元々のオブジェクトが中央に描画されます

pixelfunction関数
	ピクセル操作をluaよりかは早く実行するための関数です
	rikky_module.pixelfunction(function, userdata or table or nil)
	第1引数はピクセル操作をするときに実行する関数を渡します
	渡す関数の引数と戻り値は以下のように定義してください
	local pfunction = function(objr, objg, objb, obja, argr, argg, argb, arga, x, y)
		local r, g, b, a
		--objr, objg, objb, objaはオブジェクトのピクセルのRGBAの0から255までの値
		--argr, argg, argb, argaは第2引数で渡したピクセルのRGBAの0から255までの値、ただしnilの場合はすべて0になります
		--x, yはその位置でxは0からw - 1まで、yは0からh - 1までの値です
		--引数などで計算や処理をしてx,yの位置の色にしたいr, g, b, aを出します
		return r, g, b, a
	end

	第2引数はオブジェクトの現在のピクセルとは別のピクセルを操作する際に渡す別のピクセルデータです
	userdata : obj.getpixeldata関数やimage関数などで取得できるuserdataを渡します、ただし、横幅縦幅はオブジェクトと同じものを使ってください

	table    : 指定したtableは4通りで画像データを指定できます
		   wとhをオブジェクトの横幅と縦幅として
		   table[i] = {r = number, g = number, b = number, a = number}
		   iは0からw * h - 1まで

		   table[i] = {r = number, g = number, b = number, a = number}
		   iは1からw * hまで

		   table[y][x] = {r = number, g = number, b = number, a = number}
		   xは0からw - 1まで
		   yは0からh - 1まで

		   table[y][x] = {r = number, g = number, b = number, a = number}
		   xは1からwまで
		   yは1からhまで
		   これらの4パターンのいずれかのtableを渡してください

	nil      : 現在のオブジェクトのピクセルだけで処理を行えます

	この関数は処理をピクセルの右下から左上に向かって行います

	使用例
	local pfunc = function(r0, g0, b0, a0, r1, g1, g1, a1, x, y)
		if(r0 < 128)then
			return 0, g0, b0, a0
		else
			return r0, 0, 0, a0
		end
	end
	rikky_module.pixelfunction(pfunc)
	これを実行すると赤みが128未満は赤みを0にして、128以上は赤身だけを残すようにするものです

textsplit関数
	文字列を1文字ずつ分解して、1文字ずつをしまったテーブルを返す関数です
	文字列用のタグ<s>や<#>や<p>や<c>や<w>や<r>や<??>や&#○○;(参照文字)にも対応しています
	table = rikky_module.textsplit(string [, table])
	第1引数は分解する文字列を指定します

	第2引数は追加したいタグをテーブル内に指定します
	例えば<k>というタグを調べたい場合は{"k"}とします
	追加するタグは複数設定できます

	table = rikky_module.textsplit("ab<s140>あ<s>")
	table[1] = "a"、table[2] = "b"、table[3] = "<s140>"、table[4] = "あ"、table[5] = "<s>"
	となります

string2table関数
	文字列内のテーブルを実際のテーブルにして返します
	table = rikky_module.string2table(string)
	引数は"{}"のように""の中に波括弧を入れます
	table = rikky_module.string2table("{10,\"a\",num=5}")
	table[1] = 10、table[2] = "a"、table.num = 5
	上記のように使います

fileCS関数
foldCS関数
fontCS関数
listCS関数
checkboxCS関数
colordialogCS関数
parameterCS関数
setdialogparamCS関数
	通常のfile関数などはアニメーション効果で使い、fileCS関数はカスタムオブジェクトで使います
	それ以外は元の関数と使い方は同じです

trackbarwrite関数
	トラックバーの値を直接書き換えます
	boolean = rikky_module.trackbarwrite(number, number [, boolean])
	第1引数は書き換えたいトラックバーの番号で、0から3のいずれかです
	第2引数は書き換えたい値です
	第3引数は書き換える位置の指定で、指定しない場合やfalseは左側、trueの場合は右側の数値を書き換えます
	書き換えに成功した場合は戻り値はtrue、失敗した場合は戻り値はfalseです
	書き換える前と後が同じ値のときも失敗として扱われます

sceneload関数
	シーンのイメージを呼び出します
	拡張編集のバージョンが91e4以上でないと使えません
	boolean or number = rikky_module.sceneload(number [, number])
	第1引数は呼び出すシーンの番号で0から49のいずれかです
	第2引数は呼び出すシーンのフレーム数で0以上の数字です
	第1引数だけで呼び出すと、そのシーンの全体の長さのフレーム数を返します
	全体のフレーム数が100の場合は指定できるフレーム数は0から99までです
	アルファチャンネルが有効になっていても、背景の黒は残ります
	強引に読み込んで処理しているので、現在アルファ化は絶望的なので諦めてください
	呼び出しに成功するとtrueが返って、オブジェクトがシーンのイメージになります
	失敗するとfalseが返って、オブジェクトのイメージは1×1の何もないイメージになります
	またscneload中に自身を参照する場合はそのときも失敗とみなして、1×1のイメージになります
	参照すると無限ループに陥るため、それを防ぐ処置です
	例えばルート(シーン0)でシーン1を読み込み、シーン1ではシーン0を読み込んでいた場合、シーン1でのシーン0は結局シーン1を読み込もうとしているので失敗して、その結果を受けたイメージがシーン1内に現れます
	また、呼び出しを実行するシーンと呼び出されるシーンが同じ場合や一度呼び出しを実行したシーンを呼び出す場合も失敗になります
	カメラ制御下でカメラ制御を使っているシーンを呼び出すと、正しく描画されません

linedetection関数
	イメージ内の直線の個所を返します
	table, number = rikky_module.linedetection(number [, number [, boolean]])
	第1引数は精度の数値で、0よりも大きい数値を指定します(100が標準です)
	第2引数は透明の個所の色を指定するもので、なしの場合は黒(0)になります
	第3引数は返す位置の座標を左上を基準から中央基準に変化するものです、trueを入れると中央基準になります
	処理の関係上アルファ値を無視し、指定した色で塗りつぶされてから処理します
	戻り値は直線のデータが入ったテーブル型と、その数です
	tableには数の文だけ直線の情報が入ったtableが入っています
	table[i] : 以下のキーが入っています
		   "x0" : 直線の始端のx座標の値です
		   "y0" : 直線の始端のy座標の値です 
		   "x1" : 直線の終端のx座標の値です
		   "y1" : 直線の終端のy座標の値です

clipboard関数
	クリップボードの読み書きが行える関数です
	boolean or string or (userdata, number , number) or nil  = rikky_module.clipboard(string, [string or userdata or number [, boolean or number, number]])
	第1引数は"w"か"r"のどちらかで、"w"のときは書き込み、"r"のときは読み込みを行います
	第2引数は書き込みのときは文字を指定したときは文字を書き込み、数字やuserdata、引数なしの場合はイメージを書き込みます
	読み込みのときは"text"か"image"のどちらかを指定します
	第3引数は書き込みのとき、第2引数をuserdataにした場合のそのイメージの横幅の数値です
	読み込みのとき、"image"を指定してる場合にtrueだと戻り値をそのイメージの横幅と縦幅を返すようにします
	戻り値は書き込みのときは成功するとtrue、失敗するとfalseで、不正な値の場合はnilが返ってきます
	読み込みのときは"text"の場合はstringですがクリップボードにない場合はnilが返ってきます
	"image"の場合は読み込みに成功するとtrue、失敗するとfalseで、第3引数をtrueにしているとイメージのuserdata、イメージの横幅、イメージの縦幅で、値が不正の場合はnilが返ってきます
	書き込むとき、第2引数を0にするとオブジェクト自身、1にするとフレームバッファ、2にすると仮想バッファのイメージを使います
	例 : 文字をクリップボードに書き込む場合
	rikky_module.clipboard("w", "rikky_module.clipboard")
	例 : 仮想バッファのイメージをクリップボードに書き込む場合
	rikky_module.clipboard("w", 2)
	例 : 現在のオブジェクトのイメージをクリップボードに書き込む場合
	その1: rikky_module.clipboard("w")
	その2: rikky_module.clipboard("w", 0)
	その3: local data, w, h = obj.getpixeldata()
	       rikky_module.clipboard("w", data, w, h)

	例 : クリップボードのテキストを読み込む場合
	local str = rikky_module.clipboard("r", "text")
	例 : クリップボードのイメージを読み込む場合(オブジェクトにするパターン)
	rikky_module.clipboard("r", "image")
	例 : クリップボードのイメージを読み込む場合(イメージデータを取得するパターン)
	local data, w, h = rikky_module.clipboard("r", "image", true)

fillarea関数
	指定した位置からイメージを塗りつぶす領域をロードします
	boolean or (number, number, number, number) = rikky_module.fillarea(number, number, number [, number])
	第1引数は塗り始めるイメージの横の位置で、0以上イメージの横幅未満の数値です
	第2引数は塗り始めるイメージの縦の位置で、0以上イメージの縦幅未満の数値です
	第3引数は塗りを行うタイプで、0から24のいずれかです
	第4引数は塗り行うしきい値(基準)で、第3引数の数値のよって最大値が変わってきますアルファ値は0から255、色相は0から360、彩度は0から100、明度は0から100、輝度は0から255です
	戻り値は失敗するとfalse、成功すると塗った箇所が収まる矩形の左上の横の横の位置、左上の縦の位置、塗った領域の横幅、塗った領域の縦幅の4つの数値を返します
	塗りを行うタイプは以下です
	 0 : しきい値以上のアルファ値の領域を塗ります(引数で指定した位置がしきい値より小さい場合は失敗となります)
	 1 : しきい値以下のアルファ値の領域を塗ります(引数で指定した位置がしきい値より大きい場合は失敗となります)
	 2 : 引数で指定した位置のアルファ値以上のアルファ値の領域を塗ります
	 3 : 引数で指定した位置のアルファ値以下のアルファ値の領域を塗ります
	 4 : 引数で指定した位置のアルファ値からしきい値をプラスとマイナスした値の範囲内に収まるアルファ値の領域を塗ります
	 5 : しきい値以上の色相の領域を塗ります(引数で指定した位置がしきい値より小さい場合は失敗となります)
	 6 : しきい値以下の色相の領域を塗ります(引数で指定した位置がしきい値より大きい場合は失敗となります)
	 7 : 引数で指定した位置の色相以上の色相の領域を塗ります
	 8 : 引数で指定した位置の色相以下の色相の領域を塗ります
	 9 : 引数で指定した位置の色相からしきい値をプラスとマイナスした値の範囲内に収まる色相の領域を塗ります
	10 : しきい値以上の彩度の領域を塗ります(引数で指定した位置がしきい値より小さい場合は失敗となります)
	11 : しきい値以下の彩度の領域を塗ります(引数で指定した位置がしきい値より大きい場合は失敗となります)
	12 : 引数で指定した位置の彩度以上の彩度の領域を塗ります
	13 : 引数で指定した位置の彩度以下の彩度の領域を塗ります
	14 : 引数で指定した位置の彩度からしきい値をプラスとマイナスした値の範囲内に収まる彩度の領域を塗ります
	15 : しきい値以上の明度の領域を塗ります(引数で指定した位置がしきい値より小さい場合は失敗となります)
	16 : しきい値以下の明度の領域を塗ります(引数で指定した位置がしきい値より大きい場合は失敗となります)
	17 : 引数で指定した位置の明度以上の明度の領域を塗ります
	18 : 引数で指定した位置の明度以下の明度の領域を塗ります
	19 : 引数で指定した位置の明度からしきい値をプラスとマイナスした値の範囲内に収まる明度の領域を塗ります
	20 : しきい値以上の輝度の領域を塗ります(引数で指定した位置がしきい値より小さい場合は失敗となります)
	21 : しきい値以下の輝度の領域を塗ります(引数で指定した位置がしきい値より大きい場合は失敗となります)
	22 : 引数で指定した位置の輝度以上の輝度の領域を塗ります
	23 : 引数で指定した位置の輝度以下の輝度の領域を塗ります
	24 : 引数で指定した位置の輝度からしきい値をプラスとマイナスした値の範囲内に収まる輝度の領域を塗ります
	成功した場合は、オブジェクトイメージを白く領域を塗りつぶしたイメージにします
	例 : 100×100の青い四角の中心に20×20の赤い円がある場合
	local x, y, w, h = rikky_module.fillarea(50, 50, 9, 10)
	条件にあった領域の中心の円の部分が白で塗りつぶされ、それ以外の場所は透明になったイメージのオブジェクトはなります
	xとyはともに40でwとhはともに20です(アンチエイリアスの関係で数値は微妙に前後するかもしれません)

effect関数
	rikky_moduleでobj.effect関数を実行するものです
	rikky_module.effect(number, number [, obj.effectの引数に相当する物])
	第1引数は実行する際のobj.indexを指定する数値です
	第2引数は実行する際のobj.numを指定する数値です
	第3引数以降obj.effectで実行するときに用いる数値や文字列で、なしの場合はobj.effect()と同じになります
	obj.effect()で現在の処理以降のフィルタやスクリプトを先読みできるのはaviutlの特徴です
	ただし、その処理内で使われるobj.indexとobj.numは現在のオブジェクトのものが使われます
	obj.index=10など適当に代入しても無意味です
	それを強引に書き換える為に使うのがこの関数で、疑似個別オブジェクトを行うためのものです
	内部の話をするとスクリプト内で一度obj.effect()と引数なしで行うと、内部のパラメータは次の処理を行う準備を初めてます
	それも強引に何度も行えるようにしています
	なのでなにかしらのエラーが起こるかもしれません

midiconverter関数
midiconverteExr関数
	ます、音を出すものではありません
	midiファイル(smf)をluaでも読みやすい形式に変換するものです
	読み込んだmidファイルと同じ場所に同名で拡張子が.datになったファイルを生成します
	boolean = rikky_module.midiconverter(string)
	第1引数はmidiファイルのフルパスです
	戻り値は変換に成功するとtrue、失敗するとfalse返ってきます
	また変換後のファイルがある場合も成功としてtrueを返します
	boolean = rikky_module.midiconverterEx(table, string)
	第1引数にはmidiファイルを解析して、そのデータを用いたオブジェクトを生成するためのテーブルを渡します
	第2引数はmidiファイルのフルパスです
	戻り値は変換に成功するとtrue、失敗するとfalse返ってきます
	また変換後のファイルがある場合も成功としてtrueを返します
	オブジェクトを生成したテーブルにはいくつかのメソッドが使えるようになっています
	また変換した.datファイルの中身も同じテーブル内に収められています
	例
	local midi = {}
	local success = rikky_module.midiconverterEx(midi, "C:\\rikky.mid")
	if not success then
		return
	end
	local oldtime = midi:SetOffsetTime(10)
	上のように使います

	メソッドは現在以下のものがあります
	:関数名はmidiconverterExで引数としたテーブル変数の後に関数名をつけることを意味を表しています
	上記の例を参考にしてください
	number = :SetOffsetTime(number)
	再生時間を移動させることができます、初期状態は0で、秒数を数値で指定します、戻り値は前のoffsettimeです
	number = :SetUprange(number)
	Now系のメソッドで取得する上限を決めます、初期状態は0です、戻り値は前のuprangeです
	number = :SetDownrange(number)
	Now系のメソッドで取得する下限を決めます、初期状態は0です、戻り値は前のdownrangeです
	number = :SetTyperange(number)
	Now系のメソッドで取得する際にUprangeとDownrangeの解釈を変更します、0だと範囲なし、1だと秒数、2だと経過時間、3だと小節数です、戻り値は前のtyperangeです
	例
	midi:SetDownrange(1)
	midi:SetUprange(2)
	midi:SetTyperange(1)
	現在の時間の1秒前から2秒後までのデータを取得できるようになります
	midi:SetDownrange(480)
	midi:SetUprange(1920)
	midi:SetTyperange(2)
	現在の経過時間から480引いた数から現在の経過時間に1920を加えた数までのデータを取得できるようになります(基本的に480が1拍を表します)

	number = :Step2Time(number)
	経過時間を秒数に変換します、引数が経過時間で戻り値が秒数です
	number = :Time2Step(number)
	秒数を経過時間に変換します、引数が秒数で戻り値が経過時間です
	number, number, number = :Step2Bar(number)
	経過時間を小節数などに変換します、引数は経過時間で戻り値が小節数、拍数、その拍の経過パーセント(0から1未満)
	number = :Bar2Step(number, number, number)
	小節数などを経過時間に変換します、引数は小節数、拍数、その拍の経過パーセント(0から1未満)で戻り値が経過時間です
	string = :NoteNumber2KeyName(number)
	ノート番号を音階の文字列に変換します、引数はノート番号(60など)で戻り値が音階を表す文字列(C4など)です
	number = :KeyName2NoteNumber(string)
	音階の文字列をノート番号に変換します、引数は音階を表す文字列(C4など)で戻り値がノート番号(60など)です

	number = :GetMaxNoteNumber()
	読み込んだmidiの一番高い音のノート番号を返します
	string = :GetMaxNoteName()
	読み込んだmidiの一番高い音の音名を返します
	number = :GetMinNoteNumber()
	読み込んだmidiの一番低い音のノート番号を返します
	string = :GetMinNoteName()
	読み込んだmidiの一番低い音の音名を返します
	number = :GetTrackNum()
	読み込んだmidiのトラック数を返します
	number = :GetDeltaTime()
	読み込んだmidiの単位時間(4分音符1つ分の経過時間)を返します
	number = :GetMidiLength()
	読み込んだmidiの曲の全体の経過時間を返します
	
	Now系のメソッドはSetOffsetTimeで設定した時間プラスオブジェクトの経過時間(obj.time)をもとに現フレームにおける各データを取得します
	SetTyperangeが0(初期状態)かそれ以外かで戻り値の型や戻り値のテーブルの構造が変わるものもあります
	string or table = :GetNowScaleKey()
	type : 0
		現在のスケールのキー(CやCmなど)の文字列を返します
	type : 1,2,3
		現在の範囲内のスケールのキー(CやCmなど)が入ったテーブルを返します
		テーブルには単数または複数のテーブルが入っています
		テーブルにはstepとkeyの要素が入っていて、table[1].stepのように使います
		keyはスケールキーの文字列、stepはスケールキーになった経過時間の数値です
		複数の場合は要素が若い順に経過時間も小さくなっています
		例えば現在の経過時間が1920でtable[1].step=0、table[1].key="C"、table[2].step=3840、table[2].key="A"ならば現在のスケールキーはCメジャーとなります

	string or table = :GetNowScaleName()
	type : 0
		現在のスケールの調号(ハ長調やハ短調など)の文字列を返します
	type : 1,2,3
		現在の範囲内のスケールの調号(ハ長調やハ短調など)が入ったテーブルを返します
		テーブルには単数または複数のテーブルが入っています
		テーブル内テーブルにはstepとnameの要素があって、table[1].stepのように使います
		nameは調号の文字列、stepはその調号になった経過時間の数値です
		複数の場合は要素が若い順に経過時間も小さくなっています
		例えば現在の経過時間が1920でtable[1].step=0、table[1].name="ハ長調"、table[2].step=3840、table[2].name="イ長調"ならば現在の調号はハ長調となります

	table = :GetNowBPM()
	type : 0
		現在の現在のbpm情報が入ったテーブルを返します
		テーブルにはtempo、bpmの2つの要素があります
		tempoは単位時間(4分音符1つ分)経過する時間(マイクロ秒)の数値、bpmは1分当たりの4分音符の数を表した文字列です
	type : 1,2,3
		範囲内のbpm情報が入ったテーブルを返します
		テーブルには単数または複数のテーブルが入っています
		テーブル内テーブルにはtempo、bpm、stepの3つの要素があって、table[2].tempoのように使います
		tempoは単位時間(4分音符1つ分)経過する時間(マイクロ秒)の数値、bpmは1分当たりの4分音符の数を表した文字列、stepはこのbpmが開始する経過時間の数値です
		例えば現在の経過時間が1920でtable[1].step=0、table[1].bpm="120.00"、table[2].step=3840、table[2].name="159.00"ならば現在のbpmは120となります

	number or table = :GetNowStepNum()
	type : 0
		現在の経過時間の数値を返します
	type : 1,2,3
		現在の範囲内の経過時間が入ったテーブルを返します
		テーブルにはstep、low_step、high_stepの3つの要素があります
		stepは現在の経過時間の数値、low_stepが範囲の下限の経過時間の数値、high_stepが範囲の上限の経過時間の数値です

	table = :GetNowNote()
		typeに関わらず同一テーブルを返します
		テーブルにはトラック数の数だけテーブルを持ちます
		各テーブルには範囲または現在に該当するノートが0または単数または複数だけ入っています
		各ノートはテーブル型で1番目の要素がノート番号(C4などを表した数値)、2番目が鳴り始めの経過時間の数値、3番目が鳴り終わりの経過時間の数値、4番目がベロシティ(音の強さ)で0から1の数値です

	talbe = :GetNowExpression()
		typeに関わらず同一テーブルを返します
		テーブルにはトラック数の数だけテーブルを持ちます
		各テーブルには範囲または現在に該当するエクスプレッションが0または単数または複数だけ入っています
		各エクスプレッションはテーブル型で1番目のそのエクスプレッションになる経過時間の数値、2番目がエクスプレッションの数値(0から127)です

	.datファイルの読み方
	midiでは各イベントは独自の経過時間を用いています
	まず単位時間という単位(四分音符1つ分がどのぐらいか)が決まっています
	例えば単位時間が480で経過時間が1920ならば4拍分経過したことになります
	実際どのぐらいの時間(秒)が経過したかはbpmなど使って計算します
	bpm
	テーブルの1番目の要素は経過時間です
	2番目は四分音符1つ分のマイクロ秒です(つまり、100000で割ると秒になります)

	rhythm
	テーブルの1番目の要素は経過時間です
	2番目は拍子の分子です
	3番目は拍子の分母です

	scale
	テーブルの1番目の要素は経過時間です
	2番目はシャープまたはフラットの数です(プラスならシャープ、マイナスならフラットの数)
	3番目は長調か短調かのフラグです(0が長調、1が短調です)

	event
	eventテーブルには複数のnoteとexpressionが収められています
	noteの各要素は
	1番目が鳴らす音の番号です(60ならC4です)
	2番目が鳴り始める経過時間
	3番目が鳴り終わる経過時間
	4番目がべロシティです

	expressionの各要素は
	1番目が変化開始の経過時間です
	2番目が強さです(最大値が127で最小値が0です)

	info
	テーブルの1番目の要素は音の番号の最大値です
	2番目は音の番号の最小値です
	3番目はeventテーブルの要素数です(音が鳴るトラック数)
	4番目は単位時間です
	5番目は全体の経過時間です

settext関数
	テキストバッファを任意の文字列に置き換えられます
	boolean = rikky_module.settext(string)
	第1引数は書き換えたい文字列で、最大1024文字まで(半角全角関係なく)
	戻り値は書き換え成功ならばtrue、失敗ならばfalseを返します

soundregister関数
	オブジェクトサウンドプラグインに音声を登録するための関数です
	boolean or number = rikky_module.soundregister(string [, number, number, number, number, boolean])
	第1引数は再生させたい音声ファイルのフルパスです
	第2引数は再生させるフレーム数です
	第3引数は音声の大きさレベルで、100が等倍です
	第4引数は再生速度で、100が等倍です、最小値は0なので、マイナスにすることはできません
	第5引数はパン、つまり左右の音の振りを決める数値で、0が通常、-100が左に、100が右に全ぶりです
	第6引数は波形を前後反転（上下や左右ではありません）させるもので、主に逆再生させるときにtrueを渡します
	戻り値は音声登録が成功したらtrue、失敗ならばfalseです
	引数をファイルのパスだけ(引数の数が1つ)の場合はその音声ファイルの長さ(秒数)を返します	
	再生させられる音声ファイルの形式はaviutlの機能に依存します
	これ単体で意味なく、オブジェクトサウンドプラグインをタイムラインに置いていないと使えません
	引数なしで呼び出した場合はオブジェクトサウンドが関数を読み込める状態かの判定をbooleanで返します
	例1
	rikky_module.soundregister("C:\\wav.wav", obj.frame, 100, 100, 0)
	obj.draw()
	例1のように記述すると音声読み込みの際もobj.drawが実行されて、処理に余計な時間がかかります
	例2
	if rikky_module.soundregister() then
		rikky_module.soundregister("C:\\wav.wav", obj.frame, 100, 100, 0)
		return
	end
	obj.draw()
	例2のように記述すれば、音声読み込みの際もobj.drawが実行されずに音声のみ登録可能になります

progressbar関数
	処理の進捗度を別ウインドウで表示することができます
	boolean = rikky_module.progressbar(string, string or number [, number])
	第1引数はウインドウの処理を決めるモードの文字列で、"start", "processing", "end"のどれかを渡してください
	第2引数はモードがstartのときはウインドウのタイトル、モードがprocessingのときは進行度で0から100までです、100になると自動的にウインドウは閉じます
	第3引数はモードがstartのときのみ必要で、バーの色の数値を渡します
	戻り値は成功の場合はtrue、失敗の場合はfalseのブ―リアン型です
	ただし、processingのときはウインドウの×ボタンを押されると失敗でfalseになります
	例
	rikky_module.progressbar("start", "テスト処理中", 0xff0000)
	for i = 0, 300 do
		--基本的に進行度が100になったらウインドウが閉じます
		if not rikky_module.progressbar("processing", i / 300 * 100) then
			--ユーザーが途中で×ボタンを押したら、このように処理を分けることができます
			break
		end
	end
	--[[
	上記した通り100になるとウインドウが自動で閉じますが、100にならない場合などは最後に100を渡すか"end"で閉じます
	処理速度的には100を渡した方がいいです
	rikky_module.progressbar("processing", 100)
	rikky_module.progressbar("end")
	]]

????????????????歴史???????????????????????????????????????

	20XX extension.dllとany_key.dllとrikky_get.dllをrikky_module.dllに統合、この段階で実質ver0.3

	2016 03 03 ひな祭りにエラー報告をいただき、正しくライブラリリンクした

	2016 03 11 list関数とgetinfo関数とtype関数とglassdraw関数とconvert関数とmouse関数とaudiobuffer関数を追加、ver0.4

	2016 03 17 list関数とfont関数の共存エラーを修正、dllのバージョン0.4aに変更

	2016 ?? ?? dllのバージョン0.4bに変更

	2016 05 17 getinfo関数の種類追加、"filter"をカスタムオブジェクトで使う際のエラー訂正、rotation関数、dataload関数、image関数、setdialogparam関数の追加、dllのバージョン0.5に変更

	2016 05 26 setdialogparam関数の文字列操作の一部訂正、audiobufferの一部訂正、image関数に新要素の追加、dllのバージョン0.5aに変更 また　where_is_rikky_module.dll.exeを開発

	2016 06 03 image関数に新要素追加、getinfo関数に新しくculling、force、antialias、billboardのフラグ取得の追加、convert関数でUTF-8が扱えるように改良、dllのバージョン0.5bに変更

	2016 06 15 setdialogparam関数でのカスタムオブジェクト挙動を一部修正と16進数表示追加、convert関数のunicodeの改行における処理を変更、getinfo関数のfocusとfilterの中点におけるエラーを修正、参照アドレスのオフセット値の見直し、where_is_rikky_module.dll.exeのまとめた先が表示されない不具合を修正、dllのバージョン0.5cに変更

	2016 07 09 getinfo関数のtextの不具合を訂正、mouseのアドレス参照のエラーを訂正、dllのバージョン0.5dに変更

	2016 08 13 camerainfo関数とassign関数とcolorconvert関数とbordering関数とaxisconvert関数とaxisconvertEx関数とtextload関数を追加、
	           getinfo関数に新しくgroupの情報取得を追加、frameでのシーン機能の現フレームと全体のフレーム数を訂正、audiobuffer関数の再生ウインドでの再生を修正、rotation関数の一部使い方変更、image関数の"i+"の仕様を変更
	           dllのバージョン1.0に変更、不具合がない限りこれでおしまい

	2016 12 24 materialdraw関数とmaterialdraw_init関数を追加、getinfo関数のgroupとcamerainfo関数で発生するエラー除去、bordering関数で間引きできるように改良、image関数でidに文字列やマイナスの数値を指定できるようにし、また引数なしで起こるエラーを修正、dllのバージョン1.1に変更

	2017 01 28 getinfo関数、camerainfo関数、materialdraw_inti関数のグループ制御に関わる個所を訂正、試作版のreloadbuffer関数を追加、dllのバージョン1.1aに変更

	2017 09 04 全体的に書きなおして、rikky_memory.aufプラグインとの連携をとるようにした
        	   getinfo関数のgroupのエラーを修正、hwndのオプション3と4を4と5に改めて、3にはタイムラインのハンドルを取得できるようにした、バージョン取得で通し番号や連携するプラグインのバージョンも取得できるようにした
	           image関数のmixで戻り値を通常だとピクセルデータ、横幅、縦幅にして+をつけたときは戻り値はブーリアンで合成した画像にオブジェクトがなるように変更
	           glassdraw_init関数で新しくrefractive、offsetZ、boundaryのパラメーターを設定できるようにし、描画方法をdrawとdrawpoly両方行えるようにした
	           dllのバージョンを1.2に変更

	2017 11 18 使い方(このファイル)を全体的にリライトした
	           getinfo関数の"color"と、"path"の一部と、"text"の一部を"object"に統合した
	           getinfo関数で新しく"dialog"を指定できるようにした
	           dataload関数を廃止して、datasave関数のみでrikky_memory.aufと連携をとるようにした
	           bordering関数の第1引数に"pixel"を指定できるようにした、また内側の輪郭は時計回りになるように変更した
	           camerainfo関数でオブジェクトの横軸のベクトルax、ay、azを取得できるようにした
	           key関数でjoypadの情報を取得できるようにした
	           file関数、fold関数、font関数、list関数をすべてボタン操作でダイアログが出るように変更した
	           dllのバージョンを1.2aに変更

	2018 02 10 getinfo関数のcullingの不具合を修正、"object"でカメラ制御のzバッファを取得、テキストオブジェクトの太字や斜字などの状態を取得できるようにした
	           またgetinfo関数の"text"の不具合と、別レイヤのテキストを取得する際に<??>を含む処理をできるようにした。ただし最新版でないとエラーになります次の更新では直します
	           glassdraw関数にasyncとcullingのキーを追加
	           dllのバージョンを1.2bに変更

	2018 05 31 materialdrawEx関数、pixelfunction関数、reloadbuffer関数、parameter関数、colordialog関数、checkbox関数、ObjectOrientFigure関数、textsplit関数、string2table関数を追加
	           getinfo関数の"object"で特定の条件で正しく情報を取得できなかったことを修正
	           "text"での指定レイヤの文字列取得を対応する拡張編集で行えるようにした
	           image関数でIDを文字列にした際にエラーが起きる場合があって、それを改善
	           また"u"を指定できるようにして、色情報を取得できるようにし、"p"が正しくなかったのでそれを修正
	           bordering関数に第5引数を指定できるようにした
	           glassdraw関数にzoomとlensのキーを追加
	           materialdraw関数の処理計算方法をmaterialdrawEx関数に合せるために変更
	           dllのバージョンを1.3に変更

	2018 06 10 この本文を(glassdrawのzoomなど)を一部書き直し
		   getinfo関数でnilを渡したときに起きるエラーを除去
		   reloadbuffer関数でのメモリーエラーを修正
		   image関数でコピー指定をする際、userdataをコピーできるようにした
		   materialdrawExでpositionおよびtextureで相対的にレイヤを指定できるようにした
	           dllのバージョンを1.3aに変更

	2018 06 16 内部の処理を一部変更
		   dllのバージョンを1.3bに変更

	2018 08 09 file関数、font関数、fold関数、list関数、checkbox関数、colordialog関数、parameter関数、setdialogparam関数のカスタムオブジェクト用の関数を追加
		   fileCS関数、fontCS関数、foldCS関数、listCS関数、checkboxCS関数、colordialogCS関数、parameterCS関数、setdialogparamCS関数の説明分を追加
		   dllのバージョンを1.3cに変更

	2019 03 15 この文章の誤字脱字を修正
		   clipboard関数、fillarea関数、effect関数、midiconverter関数、midiconverterEx関数、sceneload関数、soundregister関数、linedetection関数、trackbarwrite関数、settext関数、progressbar関数を追加
		   getinfo関数で新しく"count"、"cache"、"groups"、"font"、"draw_state"を指定できるようにした
		   image関数で"u""u+"を指定する際に起こりそうなエラーを出なくした
		   image関数でイメージクリアができない場合を修繕
		   reloadbuffer関数の読み込み時に自身を再読み込みする場合はフレームバッファではなく、透明のイメージを返す仕様に変更
		   またシーン内で使用するときの不具合も改善
		   その他、細かく処理を変更、改善など行った箇所があるが、詳細は失念
		   なかったので、免責項目を追加
		   忘れてたライセンスを追加
		   dllのバージョンを1.4に変更

	2019 03 16 getinfo関数の"blend"でオプション2を追加し損ねていたので追加
		   settext関数でメモリーリークが発生していたので修正、戻り値も修正
		   reloadbuffer関数、sceneload関数で全体の長さを取得する部分の不具合を修正
		   fillarea関数を内部を一部変更
		   dllのバージョンを1.4aに変更

	2019 04 07 soundregister関数で引数なしで音を取得しているかを確認できるようにした
		   説明文の一部の脱字を修正
		   dllのバージョンを1.4bに変更

	2019 09 13 rikky_memory.aufの変更に合わせて、説明文の一部を変更(dllの内容そのものの変更はなし)
